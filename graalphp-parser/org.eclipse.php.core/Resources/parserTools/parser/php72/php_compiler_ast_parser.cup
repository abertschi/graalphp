package org.eclipse.php.internal.core.compiler.ast.parser.php72;

////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////
////    $Id: php_compiler_ast_parser.cup,v 1.2 2012/01/18 08:16:07 zzhongwei Exp $
////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////

import java.util.*;
import org.eclipse.dltk.ast.*;
import org.eclipse.dltk.ast.declarations.*;
import org.eclipse.dltk.ast.expressions.*;
import org.eclipse.dltk.ast.references.*;
import org.eclipse.dltk.ast.statements.*;
import org.eclipse.php.core.compiler.ast.nodes.*;
import org.eclipse.php.internal.core.compiler.ast.parser.*;
import org.eclipse.php.internal.core.ast.scanner.php72.*;

parser code {:

	class ModifierDocPair {
		public int modifier;
		public PHPDocBlock doc;

		public ModifierDocPair(int modifier, PHPDocBlock doc) {
			this.modifier = modifier;
			this.doc = doc;
		}
	}

	protected Expression detectScalar(Expression expr) {
		if (expr instanceof FullyQualifiedReference) {
			FullyQualifiedReference name = (FullyQualifiedReference) expr;
			if (name.getNamespace() == null) {
				return new Scalar(name.start(), name.end(), name.getName(), Scalar.TYPE_STRING);
			}
		}
		return expr;
	}

	protected int getElementTypeByUseType(int useType) {
		int elementType = 0;
		switch (useType) {
		case UseStatement.T_FUNCTION:
			elementType = FullyQualifiedReference.T_FUNCTION;
			break;
		case UseStatement.T_CONST:
			elementType = FullyQualifiedReference.T_CONSTANT;
			break;
		default:
			elementType = FullyQualifiedReference.T_TYPE;
			break;
		}
		return elementType;
	}

	@Override
	protected String getTokenName(int token) {
		return PHPTokenNames.getName(token);
	}

	@Override
	protected void report_expected_token_ids()
	{
		// XXX : really verbose, disable it completely for now
		// if (DLTKCore.DEBUG) {
		//     super.report_expected_token_ids();
		// }
	}
:}

/* terminals */

terminal String T_EXIT;
terminal String T_IF;
terminal String T_LNUMBER;
terminal String T_DNUMBER;
terminal String T_BNUMBER;
terminal String T_STRING;
terminal String T_STRING_VARNAME;
terminal String T_VARIABLE;
terminal String T_NUM_STRING;
terminal T_INLINE_HTML;
terminal String T_CHARACTER;
terminal String T_ENCAPSED_AND_WHITESPACE;
terminal String T_CONSTANT_ENCAPSED_STRING;
terminal T_OPEN_TAG_WITH_ECHO;
terminal String T_ECHO;
terminal String T_DO;
terminal String T_WHILE;
terminal String T_ENDWHILE;
terminal String T_FOR;
terminal String T_ENDFOR;
terminal String T_FOREACH;
terminal String T_ENDFOREACH;
terminal String T_DECLARE;
terminal String T_ENDDECLARE;
terminal String T_INSTANCEOF;
terminal String T_CLONE;
terminal String T_AS;
terminal String T_SWITCH;
terminal String T_ENDSWITCH;
terminal String T_CASE;
terminal String T_DEFAULT;
terminal String T_BREAK;
terminal String T_CONTINUE;
terminal String T_GOTO;
terminal CompilerAstLexer.PHPDocBlockSymbolPair T_FUNCTION;
terminal CompilerAstLexer.PHPDocBlockSymbolPair T_CONST;
terminal String T_RETURN;
terminal String T_YIELD;
terminal T_YIELD_FROM;
terminal String T_TRY;
terminal String T_CATCH;
terminal String T_THROW;
terminal String T_FINALLY;
terminal String T_USE;
terminal String T_GLOBAL;
terminal CompilerAstLexer.PHPDocBlockSymbolPair T_VAR;
terminal String T_UNSET;
terminal String T_ISSET;
terminal String T_EMPTY;
terminal T_HALT_COMPILER;
terminal CompilerAstLexer.PHPDocBlockSymbolPair T_CLASS;
terminal CompilerAstLexer.PHPDocBlockSymbolPair T_INTERFACE;
terminal String T_EXTENDS;
terminal String T_IMPLEMENTS;
terminal T_OBJECT_OPERATOR;
terminal T_DOUBLE_ARROW;
terminal String T_LIST;
terminal String T_ARRAY;
terminal T_CLASS_C;
terminal T_METHOD_C;
terminal T_FUNC_C;
terminal T_LINE;
terminal String T_FILE;
terminal String T_START_HEREDOC;
terminal T_END_HEREDOC;
terminal T_DOLLAR_OPEN_CURLY_BRACES;
terminal T_CURLY_OPEN_WITH_DOLAR;
terminal T_CURLY_OPEN;
terminal T_CURLY_CLOSE;
terminal T_PAAMAYIM_NEKUDOTAYIM;
terminal String T_NAMESPACE;
terminal T_NS_C;
terminal T_DIR;
terminal T_NS_SEPARATOR;
terminal String T_VAR_COMMENT;
terminal String T_DEFINE;

terminal String T_INCLUDE,T_INCLUDE_ONCE,T_EVAL,T_REQUIRE,T_REQUIRE_ONCE;
terminal T_COMMA;
terminal String T_LOGICAL_OR,T_LOGICAL_XOR,T_LOGICAL_AND,T_PRINT;
terminal T_EQUAL;
terminal T_PLUS_EQUAL,T_MINUS_EQUAL,T_MUL_EQUAL,T_DIV_EQUAL,T_CONCAT_EQUAL,T_MOD_EQUAL,T_AND_EQUAL,T_OR_EQUAL,T_XOR_EQUAL,T_SL_EQUAL,T_SR_EQUAL,T_POW_EQUAL;
terminal T_QUESTION_MARK;
terminal T_SEMICOLON;
terminal T_BOOLEAN_OR, T_BOOLEAN_AND;
terminal T_OR;
terminal T_KOVA;
terminal T_REFERENCE;
terminal T_IS_EQUAL,T_IS_NOT_EQUAL,T_IS_IDENTICAL,T_IS_NOT_IDENTICAL;
terminal T_IS_SMALLER_OR_EQUAL,T_IS_GREATER_OR_EQUAL;
terminal T_RGREATER;
terminal T_LGREATER;
terminal T_SL,T_SR;
terminal T_PLUS;
terminal T_MINUS;
terminal T_TIMES;
terminal T_POW;
terminal T_DIV;
terminal T_PRECENT;
terminal T_NOT;
terminal T_TILDA;
terminal T_NEKUDA;
terminal T_INC,T_DEC,T_INT_CAST,T_DOUBLE_CAST,T_STRING_CAST,T_ARRAY_CAST,T_OBJECT_CAST,T_BOOL_CAST,T_UNSET_CAST;
terminal T_AT;
terminal T_OPEN_RECT,T_CLOSE_RECT;
terminal String T_NEW;
terminal String T_ENDIF;
terminal String T_ELSEIF;
terminal String T_ELSE;
terminal CompilerAstLexer.PHPDocBlockSymbolPair T_STATIC, T_ABSTRACT, T_FINAL, T_PRIVATE, T_PROTECTED, T_PUBLIC;
terminal T_OPEN_PARENTHESE,T_CLOSE_PARENTHESE;
terminal T_NEKUDOTAIM;
terminal T_DOLLAR;
terminal T_QUATE,T_BACKQUATE,T_SINGLE_QUATE;


//php 5.4
terminal String T_INSTEADOF;
terminal CompilerAstLexer.PHPDocBlockSymbolPair T_TRAIT;
terminal String T_CALLABLE;
terminal T_TRAIT_C;

//php 5.6
terminal T_ELLIPSIS;

//php 7
terminal T_SPACESHIP;
terminal T_COALESCE;

/* Non terminals */

non terminal ModuleDeclaration thestart;
non terminal String reserved_non_modifiers;
non terminal String semi_reserved;
non terminal String identifier;
non terminal FullyQualifiedReference namespace_name;
non terminal List namespace_name_list;
non terminal UsePart use_declaration;
non terminal FullyQualifiedReference use_namespace_name;
non terminal UseStatement mixed_group_use_declaration;
non terminal UseStatement group_use_declaration;
non terminal List inline_use_declarations;
non terminal UsePart inline_use_declaration;
non terminal List use_declarations;
non terminal Integer use_type;
non terminal top_statement_list;
non terminal List namespace_statement_list;
non terminal Statement top_statement;
non terminal Statement statement;
non terminal List inner_statement_list;
non terminal Statement inner_statement;
non terminal Statement unticked_statement;
non terminal PHPCallArgumentsList unset_variables;
non terminal Expression unset_variable;
non terminal Expression use_filename;
non terminal Expression foreach_variable;
non terminal Statement for_statement;
non terminal Statement foreach_statement;
non terminal Statement declare_statement;
non terminal List[] const_list;
non terminal Block switch_case_list;
non terminal List case_list;
non terminal case_separator;
non terminal Statement while_statement;
non terminal List[] elseif_list;
non terminal List[] new_elseif_list;
non terminal Statement else_single;
non terminal Statement new_else_single;
non terminal List parameter_list;
non terminal List lexical_vars;
non terminal List lexical_var_list;
non terminal Expression lexical_var;
non terminal List non_empty_parameter_list;
non terminal FormalParameter parameter;
non terminal PHPCallArgumentsList function_call_parameter_list;
non terminal PHPCallArgumentsList non_empty_argument_list;
non terminal List simple_variable_list;
non terminal Expression simple_variable;
non terminal List static_var_list;
non terminal Expression static_var;
non terminal class_statement_list;
non terminal class_statement;
non terminal Boolean is_reference;
non terminal List echo_expr_list;
non terminal List for_expr;
non terminal List non_empty_for_expr;
non terminal Expression argument;
non terminal Expression expr_without_variable;
non terminal Expression function_call;
non terminal Expression exit_expr;
non terminal PHPCallArgumentsList ctor_arguments;
non terminal Expression scalar;
non terminal possible_comma;
non terminal Expression expr;
non terminal Expression variable_class_name;
non terminal Expression optional_expr;
non terminal Expression member_name;
non terminal Expression property_name;
non terminal Expression possible_array_pair;
non terminal Expression array_pair;
non terminal List array_pair_list;
non terminal List non_empty_array_pair_list;
non terminal List encaps_list;
non terminal List backticks_expr;
non terminal Expression encaps_var;
non terminal Expression encaps_var_offset;
non terminal Expression internal_functions_in_yacc;
non terminal String string_st;
non terminal PHPDocBlock interface_entry;
non terminal List interface_extends_list;
non terminal Expression class_name;
non terminal FullyQualifiedReference name;
non terminal FullyQualifiedReference type;
non terminal TypeReference type_expr;
non terminal TypeReference return_type;
non terminal TypeReference fully_qualified_class_name;
non terminal List property_list;
non terminal List class_const_list;
non terminal ASTNode[] class_const_decl;
non terminal CompilerAstParser.ModifierDocPair method_modifiers;
non terminal Statement method_body;
non terminal Statement named_namespace_body;
non terminal Statement namespace_body;
non terminal List non_empty_member_modifiers;
non terminal CompilerAstParser.ModifierDocPair member_modifier;
non terminal PHPMethodDeclaration function_declaration_statement;
non terminal Statement class_declaration_statement;
non terminal Expression variable;
non terminal Expression callable_variable;
non terminal Expression dereferencable;
non terminal Expression callable_expr;
non terminal Expression dereferencable_scalar;
non terminal List catches_list;
non terminal List non_empty_catches_list;
non terminal CatchClause catch_clause;
non terminal List<TypeReference> catch_name_list;
non terminal PHPMethodDeclaration unticked_function_declaration_statement;
non terminal Statement unticked_class_declaration_statement;
non terminal CompilerAstParser.ModifierDocPair class_entry_type;
non terminal TypeReference extends_from;
non terminal List implements_list;
non terminal List interface_list;
non terminal TypeReference optional_class_type;
non terminal CompilerAstParser.ModifierDocPair variable_modifiers;
non terminal Expression constant;
non terminal StaticFieldAccess static_member;
non terminal Expression new_variable;
non terminal PHPCallArgumentsList isset_variables;

non terminal Expression class_name_reference;

/* added the following rules for improving error recovery*/
non terminal Statement class_closure;
non terminal PHPMethodDeclaration function_body;
non terminal LambdaFunctionDeclaration lambda_function_body;
non terminal errorOrNot;

//php5.4
non terminal TraitUseStatement trait_use_statement;
non terminal List trait_list;
non terminal List trait_adaptations;
non terminal List trait_adaptation_list;
non terminal List non_empty_trait_adaptation_list;
non terminal TraitStatement trait_adaptation_statement;
non terminal TraitPrecedence trait_precedence;
non terminal List trait_reference_list;
non terminal Expression trait_method_reference;
non terminal FullyQualifiedTraitMethodReference trait_method_reference_fully_qualified;
non terminal TraitAlias trait_alias;
non terminal CompilerAstParser.ModifierDocPair trait_modifiers;
non terminal CompilerAstParser.ModifierDocPair non_empty_trait_modifiers;

non terminal ClassInstanceCreation new_expr;
non terminal AnonymousClassDeclaration anonymous_class;

//php5.5
non terminal FinallyClause finally_clause;
non terminal FinallyClause non_empty_finally_clause;

non terminal YieldExpression yield_expr;


precedence left T_INCLUDE, T_INCLUDE_ONCE, T_EVAL, T_REQUIRE, T_REQUIRE_ONCE;
precedence left T_COMMA;
precedence left T_LOGICAL_OR;
precedence left T_LOGICAL_XOR;
precedence left T_LOGICAL_AND;
precedence right T_PRINT;
precedence left T_EQUAL, T_PLUS_EQUAL,T_MINUS_EQUAL,T_MUL_EQUAL,T_DIV_EQUAL,T_CONCAT_EQUAL,T_MOD_EQUAL,T_AND_EQUAL,T_OR_EQUAL,T_XOR_EQUAL,T_SL_EQUAL,T_SR_EQUAL,T_POW_EQUAL;
precedence left T_QUESTION_MARK,T_SEMICOLON;
precedence right T_COALESCE;
precedence left T_BOOLEAN_OR;
precedence left T_BOOLEAN_AND;
precedence left T_OR;
precedence left T_KOVA;
precedence left T_REFERENCE;
precedence left T_ELLIPSIS;
precedence right T_YIELD;
precedence right T_DOUBLE_ARROW;
precedence right T_YIELD_FROM;

precedence nonassoc T_IS_EQUAL,T_IS_NOT_EQUAL,T_IS_IDENTICAL,T_IS_NOT_IDENTICAL;
precedence nonassoc T_RGREATER,T_IS_SMALLER_OR_EQUAL,T_LGREATER,T_IS_GREATER_OR_EQUAL;
precedence nonassoc T_SPACESHIP;
precedence left T_SL,T_SR;
precedence left T_PLUS,T_MINUS,T_NEKUDA;
precedence left T_POW,T_TIMES,T_DIV,T_PRECENT;
precedence right T_NOT;
precedence nonassoc T_INSTANCEOF;
precedence right T_TILDA,T_INC,T_DEC,T_INT_CAST,T_DOUBLE_CAST,T_STRING_CAST,T_ARRAY_CAST,T_OBJECT_CAST,T_BOOL_CAST,T_UNSET_CAST,T_AT;
precedence right T_OPEN_RECT;
precedence nonassoc T_NEW, T_CLONE;
precedence left T_ELSEIF;
precedence left T_ELSE;
precedence left T_ENDIF;
precedence right T_STATIC, T_ABSTRACT, T_FINAL, T_PRIVATE, T_PROTECTED, T_PUBLIC;

thestart ::=
top_statement_list:statementList
{:
	PHPModuleDeclaration program = parser.getModuleDeclaration();

	PHPAstLexer phpAstLexer = (PHPAstLexer) parser.getScanner();
	List commentList = phpAstLexer.getCommentList();
	Iterator i = commentList.iterator();
	while (i.hasNext()) {
		Object c = i.next();
		if (c instanceof VarComment) {
			program.getVarComments().add((VarComment) c);
		} else if (c instanceof PHPDocBlock) {
			program.getPHPDocBlocks().add((PHPDocBlock) c);
		}
		if (c instanceof Comment) {
			program.getCommentList().add((Comment) c);
		}
	}

	program.setStart(statementListleft);
	program.setEnd(statementListright + 1);
	RESULT = program;
:}
;

reserved_non_modifiers ::=
T_INCLUDE:v
{:
	RESULT = v;
:}
| T_INCLUDE_ONCE:v
{:
	RESULT = v;
:}
| T_EVAL:v
{:
	RESULT = v;
:}
| T_REQUIRE:v
{:
	RESULT = v;
:}
| T_REQUIRE_ONCE:v
{:
	RESULT = v;
:}
| T_LOGICAL_OR:v
{:
	RESULT = v;
:}
| T_LOGICAL_XOR:v
{:
	RESULT = v;
:}
| T_LOGICAL_AND:v
{:
	RESULT = v;
:}
| T_INSTANCEOF:v
{:
	RESULT = v;
:}
| T_NEW:v
{:
	RESULT = v;
:}
| T_CLONE:v
{:
	RESULT = v;
:}
| T_EXIT:v
{:
	RESULT = v;
:}
| T_IF:v
{:
	RESULT = v;
:}
| T_ELSEIF:v
{:
	RESULT = v;
:}
| T_ELSE:v
{:
	RESULT = v;
:}
| T_ENDIF:v
{:
	RESULT = v;
:}
| T_ECHO:v
{:
	RESULT = v;
:}
| T_DO:v
{:
	RESULT = v;
:}
| T_WHILE:v
{:
	RESULT = v;
:}
| T_ENDWHILE:v
{:
	RESULT = v;
:}
| T_FOR:v
{:
	RESULT = v;
:}
| T_ENDFOR:v
{:
	RESULT = v;
:}
| T_FOREACH:v
{:
	RESULT = v;
:}
| T_ENDFOREACH:v
{:
	RESULT = v;
:}
| T_DECLARE:v
{:
	RESULT = v;
:}
| T_ENDDECLARE:v
{:
	RESULT = v;
:}
| T_AS:v
{:
	RESULT = v;
:}
| T_TRY:v
{:
	RESULT = v;
:}
| T_CATCH:v
{:
	RESULT = v;
:}
| T_FINALLY:v
{:
	RESULT = v;
:}
| T_THROW:v
{:
	RESULT = v;
:}
| T_USE:v
{:
	RESULT = v;
:}
| T_INSTEADOF:v
{:
	RESULT = v;
:}
| T_GLOBAL:v
{:
	RESULT = v;
:}
| T_VAR:v
{:
	RESULT = v.value;
:}
| T_UNSET:v
{:
	RESULT = v;
:}
| T_ISSET:v
{:
	RESULT = v;
:}
| T_EMPTY:v
{:
	RESULT = v;
:}
| T_CONTINUE:v
{:
	RESULT = v;
:}
| T_GOTO:v
{:
	RESULT = v;
:}
| T_FUNCTION:v
{:
	RESULT = v.value;
:}
| T_CONST:v
{:
	RESULT = v.value;
:}
| T_RETURN:v
{:
	RESULT = v;
:}
| T_PRINT:v
{:
	RESULT = v;
:}
| T_YIELD:v
{:
	RESULT = v;
:}
| T_LIST:v
{:
	RESULT = v;
:}
| T_SWITCH:v
{:
	RESULT = v;
:}
| T_ENDSWITCH:v
{:
	RESULT = v;
:}
| T_CASE:v
{:
	RESULT = v;
:}
| T_DEFAULT:v
{:
	RESULT = v;
:}
| T_BREAK:v
{:
	RESULT = v;
:}
| T_ARRAY:v
{:
	RESULT = v;
:}
| T_CALLABLE:v
{:
	RESULT = v;
:}
| T_EXTENDS:v
{:
	RESULT = v;
:}
| T_IMPLEMENTS:v
{:
	RESULT = v;
:}
| T_NAMESPACE:v
{:
	RESULT = v;
:}
| T_TRAIT:v
{:
	RESULT = v.value;
:}
| T_INTERFACE:v
{:
	RESULT = v.value;
:}
| T_CLASS:v
{:
	RESULT = v.value;
:}
;

semi_reserved ::=
reserved_non_modifiers:v
{:
	RESULT = v;
:}
| T_STATIC:v
{:
	RESULT = v.value;
:}
| T_ABSTRACT:v
{:
	RESULT = v.value;
:}
| T_FINAL:v
{:
	RESULT = v.value;
:}
| T_PRIVATE:v
{:
	RESULT = v.value;
:}
| T_PROTECTED:v
{:
	RESULT = v.value;
:}
| T_PUBLIC:v
{:
	RESULT = v.value;
:}
;

identifier ::=
string_st:v
{:
	RESULT = v;
:}
| semi_reserved:v
{:
	RESULT = v;
:}
;

namespace_name ::=
namespace_name_list:list
{:
	StringBuilder namespaceNameBuf = new StringBuilder();
	FullyQualifiedReference fullyQualifiedName = null;
	Iterator i = list.iterator();
	while (i.hasNext()) {
		String str = (String) i.next();
		if (i.hasNext()) {
			if (namespaceNameBuf.length() != 0) {
				namespaceNameBuf.append('\\');
			}
			namespaceNameBuf.append(str);
		} else {
			NamespaceReference namespaceRef = (namespaceNameBuf.length() != 0) ?
				new NamespaceReference(listleft, listright - str.length() - 1, namespaceNameBuf.toString()) : null;
			fullyQualifiedName = new FullyQualifiedReference(listleft, listright, str, namespaceRef);
		}
	}
	RESULT = fullyQualifiedName;
:}
;

namespace_name_list ::=
string_st:name
{:
	List list = new LinkedList();
	list.add(name);
	RESULT = list;
:}
|
namespace_name_list:list T_NS_SEPARATOR string_st:name
{:
	list.add(name);
	RESULT = list;
:}
;

namespace_statement_list ::=
namespace_statement_list:statementList top_statement:statement
{:
	// Ignore null statements
	if (statement != null) {
		statementList.add(statement);
		if (statement.getKind() == ASTNodeKinds.AST_ERROR) {
			if (!parser.declarations.isEmpty()) {
				Statement node = parser.declarations.peek();
				if (node.sourceStart() == statement.sourceStart() && node.sourceEnd() == statement.sourceEnd()) {
					statementList.add(parser.declarations.pop());
				}
			}
		}
	}
	if (!(parser.declarations.peek() instanceof NamespaceDeclaration)) {
		statementList.add(parser.declarations.pop());
	}
	RESULT = statementList;
:}

| /* empty */
{:
	RESULT = new LinkedList();
:}
;

name ::=
namespace_name:name
{:
	RESULT = name;
:}

| T_NAMESPACE:s T_NS_SEPARATOR namespace_name:name
{:
	if (name.getNamespace() == null) {
		name.setNamespace(new NamespaceReference(nameleft, nameleft, ""));
	}
	name.getNamespace().setLocal(true);

	RESULT = name;
:}

| T_NS_SEPARATOR:s namespace_name:name
{:
	NamespaceReference namespace = name.getNamespace();
	if (namespace == null) {
		namespace = new NamespaceReference(sleft, sright, "");
		name.setNamespace(namespace);
	}
	namespace.setGlobal(true);
	namespace.setStart(sleft);
	name.setStart(sleft);
	RESULT = name;
:}
;

top_statement_list ::=
top_statement_list:statementList top_statement:statement
{:
	if (statement != null) {
		parser.addStatement(statement);
		if (parser.pendingStatement != null) {
			parser.addStatement(parser.pendingStatement);
			parser.pendingStatement = null;
		}
	}
	while (!parser.declarations.isEmpty()) {
		parser.addStatement(parser.declarations.pop());
	}
:}

| /* empty */
;

top_statement ::=
statement:statement
{:
	RESULT = statement;
:}

| function_declaration_statement:statement
{:
	RESULT = statement;
:}

| class_declaration_statement:statement
{:
	RESULT = statement;
:}

| T_NAMESPACE:start namespace_name:name
{:
	NamespaceDeclaration namespace = new NamespaceDeclaration(startleft, nameright, nameleft, nameright, name.getFullyQualifiedName(), null, null);
	parser.addDeclarationStatement(namespace);
	parser.declarations.push(namespace);
:}
named_namespace_body:body
{:
	RESULT = body;
:}

| T_NAMESPACE:start
{:
	NamespaceDeclaration namespace = new NamespaceDeclaration(startleft, startright, startright, startright, NamespaceDeclaration.GLOBAL, null, null);
	parser.addDeclarationStatement(namespace);
	parser.declarations.push(namespace);
:}
namespace_body:body
{:
	RESULT = body;
:}

| T_USE:start mixed_group_use_declaration:useStatement T_SEMICOLON:end
{:
	useStatement.setStart(startleft);
	useStatement.setEnd(endright);
	for (UsePart usePart : useStatement.getParts()) {
		usePart.setGroupNamespace(useStatement.getNamespace());
	}
	parser.declarations.push(useStatement);
:}

| T_USE:start use_type:useType group_use_declaration:useStatement T_SEMICOLON:end
{:
	useStatement.setStart(startleft);
	useStatement.setEnd(endright);
	useStatement.setStatementType(useType);
	int elementType = getElementTypeByUseType(useType);
	for (UsePart usePart : useStatement.getParts()) {
		usePart.setStatementType(useType);
		usePart.getNamespace().setElementType(elementType);
		usePart.setGroupNamespace(useStatement.getNamespace());
	}
	parser.declarations.push(useStatement);
:}

| T_USE:start use_declarations:useDeclList T_SEMICOLON:end
{:
	parser.declarations.push(new UseStatement(startleft, endright, useDeclList));
:}

| T_USE:start use_type:useType use_declarations:useDeclList T_SEMICOLON:end
{:
	int elementType = getElementTypeByUseType(useType);
	for (Object usePart : useDeclList) {
		((UsePart) usePart).setStatementType(useType);
		((UsePart) usePart).getNamespace().setElementType(elementType);
	}
	parser.declarations.push(new UseStatement(startleft, endright, useDeclList, useType));
:}

| T_CONST:s const_list:decList T_SEMICOLON
{:
	Iterator i = decList[0].iterator();
	int pos = 0;
	while (i.hasNext()) {
		ConstantReference constant = (ConstantReference) i.next();
		Expression initializer = (Expression) decList[1].get(pos);

		int end = (initializer == null ? constant.sourceEnd() : initializer.sourceEnd());
		parser.declarations.push(new ConstantDeclaration(constant, initializer, sleft, end, pos == 0 ? s.doc : null));
		pos++;
	}
:}
;

named_namespace_body ::=
T_SEMICOLON:end /* unbracketed syntax */
{:
	NamespaceDeclaration namespaceDeclaration = (NamespaceDeclaration) parser.declarations.pop();
	namespaceDeclaration.setEnd(endright);
	namespaceDeclaration.setBracketed(false);

	parser.currentNamespace = namespaceDeclaration;

	parser.metUnbracketedNSDecl = true;
	if (parser.metBracketedNSDecl) {
		parser.reportError(new ASTError(namespaceDeclaration.sourceStart(), endright), "Cannot mix bracketed namespace declarations with unbracketed namespace declarations");
	}

	RESULT = namespaceDeclaration;
:}
| namespace_body:body
{:
	RESULT = body;
:}
;

namespace_body ::=
T_CURLY_OPEN:start namespace_statement_list:statementList T_CURLY_CLOSE:end
{:
	NamespaceDeclaration namespaceDeclaration = (NamespaceDeclaration) parser.declarations.pop();
	namespaceDeclaration.getBody().setStart(startleft);
	namespaceDeclaration.getBody().setEnd(endright);
	namespaceDeclaration.getBody().getStatements().clear();
	namespaceDeclaration.getBody().acceptStatements(statementList);
	namespaceDeclaration.setEnd(endright);

	parser.metBracketedNSDecl = true;
	if (parser.metUnbracketedNSDecl) {
		parser.reportError(new ASTError(namespaceDeclaration.sourceStart(), endright), "Cannot mix bracketed namespace declarations with unbracketed namespace declarations");
	}

	RESULT = namespaceDeclaration;
:}
| error:theError
{:
	RESULT = (NamespaceDeclaration) parser.declarations.pop();
:}
;

use_type ::=
T_FUNCTION
{:
	RESULT = UseStatement.T_FUNCTION;
:}
| T_CONST
{:
	RESULT = UseStatement.T_CONST;
:}
;

group_use_declaration ::=
use_namespace_name:namespaceName T_CURLY_OPEN use_declarations:useDeclList possible_comma T_CURLY_CLOSE:end
{:
	RESULT = new UseStatement(namespaceNameleft, endright, namespaceName, useDeclList);
:}
;

mixed_group_use_declaration ::=
use_namespace_name:namespaceName T_CURLY_OPEN inline_use_declarations:useDeclList possible_comma T_CURLY_CLOSE:end
{:
	RESULT = new UseStatement(namespaceNameleft, endright, namespaceName, useDeclList);
:}
;

inline_use_declarations ::=
inline_use_declarations:useDeclList T_COMMA inline_use_declaration:useDecl
{:
	useDeclList.add(useDecl);
	RESULT = useDeclList;
:}
| inline_use_declaration:useDecl
{:
	List useDeclList = new LinkedList();
	useDeclList.add(useDecl);
	RESULT = useDeclList;
:}
;

inline_use_declaration ::=
use_declaration:useDeclaration
{:
	RESULT = useDeclaration;
:}

| use_type:useType use_declaration:useDeclaration
{:
	int elementType = getElementTypeByUseType(useType);
	useDeclaration.getNamespace().setElementType(elementType);
	useDeclaration.setStatementType(useType);
	RESULT = useDeclaration;
:}
;

use_declarations ::=
use_declarations:useDeclList T_COMMA use_declaration:useDecl
{:
	useDeclList.add(useDecl);
	RESULT = useDeclList;
:}

| use_declaration:useDecl
{:
	List useDeclList = new LinkedList();
	useDeclList.add(useDecl);
	RESULT = useDeclList;
:}
;

use_declaration ::=
namespace_name:name
{:
	name.setElementType(FullyQualifiedReference.T_TYPE);
	UsePart usePart = new UsePart(name, null);
	RESULT = usePart;
:}

| namespace_name:name T_AS T_STRING:aliasName
{:
	name.setElementType(FullyQualifiedReference.T_TYPE);
	UsePart usePart = new UsePart(name,
		new SimpleReference(aliasNameleft, aliasNameright, aliasName));
	RESULT = usePart;
:}

| T_NS_SEPARATOR:s namespace_name:name
{:
	// NB: leading backslash is optional and has no special meaning here, so totally ignore it
	name.setElementType(FullyQualifiedReference.T_TYPE);
	UsePart usePart = new UsePart(name, null);
	RESULT = usePart;
:}

| T_NS_SEPARATOR:s namespace_name:name T_AS T_STRING:aliasName
{:
	// NB: leading backslash is optional and has no special meaning here, so totally ignore it
	name.setElementType(FullyQualifiedReference.T_TYPE);
	UsePart usePart = new UsePart(name,
		new SimpleReference(aliasNameleft, aliasNameright, aliasName));
	RESULT = usePart;
:}
;

use_namespace_name ::=
namespace_name_list:list T_NS_SEPARATOR:end
{:
	StringBuilder namespaceNameBuf = new StringBuilder();
	FullyQualifiedReference fullyQualifiedName = null;
	Iterator i = list.iterator();
	while (i.hasNext()) {
		String str = (String) i.next();
		if (i.hasNext()) {
			if (namespaceNameBuf.length() != 0) {
				namespaceNameBuf.append('\\');
			}
			namespaceNameBuf.append(str);
		} else {
			NamespaceReference namespaceRef = (namespaceNameBuf.length() != 0) ?
				new NamespaceReference(listleft, listright - str.length() - 1, namespaceNameBuf.toString()) : null;
			fullyQualifiedName = new FullyQualifiedReference(listleft, endright, str, namespaceRef);
		}
	}
	RESULT = fullyQualifiedName;
:}

| T_NS_SEPARATOR:s namespace_name_list:list T_NS_SEPARATOR:end
{:
	// NB: leading backslash is optional and has no special meaning here, so totally ignore it
	StringBuilder namespaceNameBuf = new StringBuilder();
	FullyQualifiedReference fullyQualifiedName = null;
	Iterator i = list.iterator();
	while (i.hasNext()) {
		String str = (String) i.next();
		if (i.hasNext()) {
			if (namespaceNameBuf.length() != 0) {
				namespaceNameBuf.append('\\');
			}
			namespaceNameBuf.append(str);
		} else {
			NamespaceReference namespaceRef = (namespaceNameBuf.length() != 0) ?
				new NamespaceReference(sright, listright - str.length() - 1, namespaceNameBuf.toString()) : null;
			fullyQualifiedName = new FullyQualifiedReference(sright, endright, str, namespaceRef);
		}
	}
	RESULT = fullyQualifiedName;
:}
;

inner_statement_list ::=
inner_statement_list:statementList inner_statement:statement
{:
	// Ignore null statements
	if (statement != null) {
		statementList.add(statement);
		if (statement.getKind() == ASTNodeKinds.AST_ERROR) {
			if (!parser.declarations.isEmpty()) {
				Statement node = parser.declarations.peek();
				if (node.sourceStart() == statement.sourceStart() && node.sourceEnd() == statement.sourceEnd()) {
					statementList.add(parser.declarations.pop());
				}
			}
		}
	}
	RESULT = statementList;
:}

| /* empty */
{:
	RESULT = new LinkedList();
:}
;

inner_statement ::=
statement:statement
{:
	RESULT = statement;
:}

| function_declaration_statement:statement
{:
	RESULT = statement;
:}

| class_declaration_statement:statement
{:
	RESULT = statement;
:}
;

statement ::=
unticked_statement:statement
{:
	RESULT = statement;
:}
| T_STRING:label T_NEKUDOTAIM:end
{:
	RESULT = new GotoLabel(labelleft, endright, label);
:}
| error:theError /* error statement */
{:
	parser.reportError();
	ASTError error = new ASTError(theErrorleft, theErrorright);
	RESULT = error;
:}
| T_VAR_COMMENT
;

unticked_statement ::=
T_CURLY_OPEN:token
{:
	Block block = new Block(tokenleft, tokenleft, new LinkedList());
	parser.declarations.push(block);

:}
inner_statement_list:statementList T_CURLY_CLOSE:end
{:
	Block block = (Block) parser.declarations.pop();
	block.setEnd(endright);
	block.getStatements().clear();
	block.acceptStatements(statementList);

	RESULT = block;
:}

| T_IF:token T_OPEN_PARENTHESE expr:condition T_CLOSE_PARENTHESE statement:iftrue elseif_list:elseif else_single:iffalse
{:
	Expression innerCondition = null;
	Statement trueStatement = null;
	Statement falseStatement = iffalse;

	for (int i = 0; i < elseif[0].size(); i++) {
		innerCondition = (Expression) elseif[0].get(i);
		trueStatement = (Statement) elseif[1].get(i);
		int start = ((Integer) elseif[2].get(i)).intValue();
		falseStatement = new IfStatement(start, iffalseright, innerCondition, trueStatement, falseStatement);
	}
	IfStatement ifStatement = new IfStatement(tokenleft, iffalseright, condition, iftrue, falseStatement);

	RESULT = ifStatement;
:}

| T_IF:token T_OPEN_PARENTHESE expr:condition T_CLOSE_PARENTHESE T_NEKUDOTAIM:colon inner_statement_list:ifTrueStatementList new_elseif_list:elseif new_else_single:iffalse T_ENDIF T_SEMICOLON:end
{:
	Expression innerCondition = null;
	Statement trueStatement = null;
	Statement falseStatement = iffalse;

	for (int i = 0; i < elseif[0].size(); i++) {
		innerCondition = (Expression) elseif[0].get(i);
		trueStatement = (Statement) elseif[1].get(i);
		int start = ((Integer) elseif[2].get(i)).intValue();
		falseStatement = new IfStatement(start, iffalseright, innerCondition, trueStatement, falseStatement);
	}
	Block block = new Block(colonleft, ifTrueStatementListright, ifTrueStatementList);

	RESULT = new IfStatement(tokenleft, iffalseright, condition, block, falseStatement);
:}

| T_WHILE:token T_OPEN_PARENTHESE expr:expr T_CLOSE_PARENTHESE while_statement:statement
{:
	WhileStatement whileStatement = new WhileStatement(tokenleft, statementright, expr, statement);
	RESULT = whileStatement;
:}

| T_DO:token statement:statement T_WHILE T_OPEN_PARENTHESE expr:expr T_CLOSE_PARENTHESE T_SEMICOLON:end
{:
	DoStatement doStatement = new DoStatement(tokenleft, endright, expr, statement);
	RESULT = doStatement;
:}

| T_FOR:token T_OPEN_PARENTHESE for_expr:initializations T_SEMICOLON for_expr:conditions T_SEMICOLON for_expr:increasements T_CLOSE_PARENTHESE for_statement:statement
{:
	RESULT = new ForStatement(tokenleft, statementright, initializations, conditions, increasements, statement);
:}

| T_SWITCH:token T_OPEN_PARENTHESE expr:expr T_CLOSE_PARENTHESE switch_case_list:caseBlock
{:
	SwitchStatement switchStatement = new SwitchStatement(tokenleft, caseBlockright, expr, caseBlock);
	RESULT = switchStatement;
:}

| T_BREAK:token T_SEMICOLON:end
{:
	RESULT = new BreakStatement(tokenleft, endright);
:}

| T_BREAK:token expr:expr T_SEMICOLON:end
{:
	RESULT = new BreakStatement(tokenleft, endright, expr);
:}

| T_CONTINUE:token T_SEMICOLON:end
{:
	RESULT = new ContinueStatement(tokenleft, endright);
:}

| T_CONTINUE:token expr:expr T_SEMICOLON:end
{:
	RESULT = new ContinueStatement(tokenleft, endright, expr);
:}

| T_RETURN:token T_SEMICOLON:end
{:
	RESULT = new ReturnStatement(tokenleft, endright);
:}

| T_RETURN:token expr_without_variable:expr T_SEMICOLON:end
{:
	RESULT = new ReturnStatement(tokenleft, endright, expr);
:}

| T_RETURN:token variable:expr T_SEMICOLON:end
{:
	RESULT = new ReturnStatement(tokenleft, endright, expr);
:}

| T_GLOBAL:start simple_variable_list:list T_SEMICOLON:end
{:
	RESULT = new GlobalStatement(startleft, endright, list);
:}

| T_STATIC:start static_var_list:list T_SEMICOLON:end
{:
	RESULT = new StaticStatement(startleft, endright, list);
:}

| T_ECHO:start echo_expr_list:exprList T_SEMICOLON:end
{:
	RESULT = new EchoStatement(startleft, endright, exprList);
:}

| T_INLINE_HTML

| expr:expr T_SEMICOLON:end
{:
	RESULT = new ExpressionStatement(exprleft, endright, expr);
:}

| T_USE:start use_filename:expr T_SEMICOLON:end
{:
	PHPCallArgumentsList list = new PHPCallArgumentsList(expr.sourceStart(), expr.sourceEnd());
	list.addNode(expr);
	SimpleReference functionName = new SimpleReference(startleft, startright, "use");
	PHPCallExpression functionInvocation = new PHPCallExpression(startleft, exprright, null, functionName, list);
	RESULT = new ExpressionStatement(startleft, endright, functionInvocation);
:}

| T_UNSET:start T_OPEN_PARENTHESE:openPar unset_variables:list possible_comma T_CLOSE_PARENTHESE:closePar T_SEMICOLON:end
{:
	list.setStart(openParright);
	list.setEnd(closeParleft);
	SimpleReference functionName = new SimpleReference(startleft, startright, "unset");
	PHPCallExpression functionInvocation = new PHPCallExpression(startleft, closeParright, null, functionName, list);
	RESULT = new ExpressionStatement(startleft, endright, functionInvocation);
:}

| T_FOREACH:token T_OPEN_PARENTHESE expr:expr T_AS foreach_variable:var T_CLOSE_PARENTHESE foreach_statement:statement
{:
	RESULT = new ForEachStatement(tokenleft, statementright, expr, var, statement);
:}

| T_FOREACH:token T_OPEN_PARENTHESE expr:expr T_AS foreach_variable:key T_DOUBLE_ARROW foreach_variable:value T_CLOSE_PARENTHESE foreach_statement:statement
{:
	RESULT = new ForEachStatement(tokenleft, statementright, expr, key, value, statement);
:}

| T_DECLARE:start T_OPEN_PARENTHESE const_list:lists T_CLOSE_PARENTHESE declare_statement:statement
{:
	List names = new LinkedList();
	for (Object v : lists[0]) {
		names.add(((ConstantReference) v).getName());
	}
	RESULT = new DeclareStatement(startleft, statementright, names, lists[1], statement);
:}

| T_SEMICOLON:token /* empty statement */
{:
	RESULT = new EmptyStatement(tokenleft, tokenright);
:}

| T_TRY:start T_CURLY_OPEN:tryBlockStart inner_statement_list:tryList T_CURLY_CLOSE:tryBlockEnd
catches_list:catchesList
finally_clause:finallyClause
{:
	TryStatement s = new TryStatement(startleft, finallyClause != null ? finallyClauseright : catchesListright, new Block(tryBlockStartleft, tryBlockEndright, tryList), catchesList, finallyClause);
	if (finallyClause == null && catchesList.size() == 0) {
		parser.reportError(new ASTError(tryBlockEndleft, tryBlockEndright), "syntax error, catch or finally clause expected");
		parser.pendingStatement = s;
	}

	RESULT = s;
:}

| T_THROW:token expr:expr T_SEMICOLON:end
{:
	RESULT = new ThrowStatement(tokenleft, endright, expr);
:}

| T_GOTO:start T_STRING:label T_SEMICOLON:end
{:
	RESULT = new GotoStatement(startleft, endright, label);
:}

| T_OPEN_TAG_WITH_ECHO:start echo_expr_list:exprList T_SEMICOLON:end
{:
	RESULT = new EchoStatement(exprListleft, endright, exprList);
:}
;

catches_list ::=
non_empty_catches_list:list
{:
	RESULT = list;
:}

| /* empty */
{:
	RESULT = new LinkedList();
:}
;

non_empty_catches_list ::=
catch_clause:catch_statement
{:
	List list = new LinkedList();
	list.add(catch_statement);
	RESULT = list;
:}
| non_empty_catches_list:list catch_clause:catch_statement
{:
	list.add(catch_statement);
	RESULT = list;
:}
;

catch_clause ::=
T_CATCH:catch_word T_OPEN_PARENTHESE catch_name_list:catch_name_list T_VARIABLE:var T_CLOSE_PARENTHESE
 T_CURLY_OPEN:catchBlockStart inner_statement_list:catchList T_CURLY_CLOSE:catchBlockEnd
{:
	Block catchBlock = new Block(catchBlockStartleft, catchBlockEndright, catchList);
	VariableReference variable = new VariableReference(varleft, varright, var, PHPVariableKind.LOCAL);
	RESULT = new CatchClause(catch_wordleft, catchBlockEndright, catch_name_list, variable, catchBlock);
:}
;

catch_name_list ::=
fully_qualified_class_name:name
{:
	List list = new LinkedList<TypeReference>();
	list.add(name);
	RESULT = list;
:}
| catch_name_list:list T_OR fully_qualified_class_name:name
{:
	list.add(name);
	RESULT = list;
:}
;

finally_clause ::=
non_empty_finally_clause:clause
{:
	RESULT = clause;
:}
| /* empty */
{:
	RESULT = null;
:}
;

non_empty_finally_clause ::=
T_FINALLY:finally_word T_CURLY_OPEN:finallyBlockStart inner_statement_list:finallyList T_CURLY_CLOSE:finallyBlockEnd
{:
	Block finallyBlock = new Block(finallyBlockStartleft, finallyBlockEndright, finallyList);
	FinallyClause finallyClause = new FinallyClause(finally_wordleft, finallyBlockEndright, finallyBlock);
	RESULT = finallyClause;
:}
;

unset_variables ::=
unset_variable:var
{:
	PHPCallArgumentsList list = new PHPCallArgumentsList();
	list.addNode(var);
	RESULT = list;
:}

| unset_variables:list T_COMMA unset_variable:var
{:
	list.addNode(var);
	RESULT = list;
:}
;

unset_variable ::=
variable:var
{:
	RESULT = var;
:}
;

use_filename ::=
T_CONSTANT_ENCAPSED_STRING:scalar
{:
	Scalar s = new Scalar(scalarleft, scalarright, scalar, Scalar.TYPE_STRING);
	RESULT = s;
:}

| T_OPEN_PARENTHESE:start T_CONSTANT_ENCAPSED_STRING:scalar T_CLOSE_PARENTHESE:end
{:
	Scalar s = new Scalar(scalarleft, scalarright, scalar, Scalar.TYPE_STRING);
	RESULT = s;
:}
;

function_declaration_statement ::=
unticked_function_declaration_statement:functionDeclaration
{:
	RESULT = functionDeclaration;
:}
;

class_declaration_statement ::=
unticked_class_declaration_statement:classDeclaration
{:
	RESULT = classDeclaration;
:}
;

is_reference ::=
/* empty */
{:
	RESULT = Boolean.FALSE;
:}
| T_REFERENCE
{:
	RESULT = Boolean.TRUE;
:}
;

unticked_function_declaration_statement ::=
T_FUNCTION:start is_reference:isReference string_st:functionName
{:
	PHPMethodDeclaration functionDeclaration = new PHPMethodDeclaration(startleft, functionNameright, functionNameleft, functionNameright, functionName, 0, null, new Block(functionNameright, functionNameright, null), isReference.booleanValue(), start.doc);
	parser.addDeclarationStatement(functionDeclaration);
	parser.declarations.push(functionDeclaration);
:}
T_OPEN_PARENTHESE parameter_list:paramList T_CLOSE_PARENTHESE:closeParenthese
{:
	PHPMethodDeclaration functionDeclaration = (PHPMethodDeclaration) parser.declarations.peek();
	functionDeclaration.acceptArguments(paramList);
	functionDeclaration.setEnd(closeParentheseright);
:}
return_type:returnType
{:
	PHPMethodDeclaration functionDeclaration = (PHPMethodDeclaration) parser.declarations.peek();
	functionDeclaration.setReturnType(returnType);
:}
function_body:body
{:
	RESULT = body;
:}
;

function_body ::=
T_CURLY_OPEN:blockStart inner_statement_list:statementList T_CURLY_CLOSE:blockEnd
{:
	PHPMethodDeclaration functionDeclaration = (PHPMethodDeclaration) parser.declarations.pop();
	Block block = functionDeclaration.getBody();
	block.setStart(blockStartleft);
	block.setEnd(blockEndright);
	block.getStatements().clear();
	block.acceptStatements(statementList);
	functionDeclaration.setEnd(blockEndright);
	RESULT = functionDeclaration;
:}
| error:theError
{:
	RESULT = (PHPMethodDeclaration) parser.declarations.pop();
:}
;

unticked_class_declaration_statement ::=
class_entry_type:modifier T_STRING:className
{:
	ClassDeclaration classDeclaration;
	if (modifier.modifier == org.eclipse.php.core.compiler.IPHPModifiers.AccTrait) {
		classDeclaration = new TraitDeclaration(modifierleft, classNameright,
			classNameleft, classNameright, modifier.modifier, className, null, null,
			new Block(classNameright, classNameright, null), modifier.doc);
	}else{
		classDeclaration = new ClassDeclaration(modifierleft, classNameright,
			classNameleft, classNameright, modifier.modifier, className, null, null,
			new Block(classNameright, classNameright, null), modifier.doc);
	}
	classDeclaration.setRecovered(true);
	parser.addDeclarationStatement(classDeclaration);
	parser.declarations.push(classDeclaration);
:}
extends_from:superClass errorOrNot implements_list:interfaces
{:
	ClassDeclaration classDeclaration = (ClassDeclaration) parser.declarations.peek();
	if (superClass != null) {
		if (classDeclaration.getModifiers() == org.eclipse.php.core.compiler.IPHPModifiers.AccTrait) {
			parser.reportError(new ASTError(classDeclaration.getNameStart(), classDeclaration.getNameEnd()), String.format("A trait (%s) cannot extend a class. Traits can only be composed from other traits with the 'use' keyword", classDeclaration.getName()));
		} else {
			classDeclaration.setSuperClass(superClass);
		}
	}
	if (interfaces != null) {
		if (classDeclaration.getModifiers() == org.eclipse.php.core.compiler.IPHPModifiers.AccTrait && interfaces.size() > 0) {
		SimpleReference node = (SimpleReference) interfaces.get(0);
			parser.reportError(new ASTError(node.sourceStart(), node.sourceEnd()), String.format("Cannot use '%s' as interface on '%s' since it is a Trait", node.getName(), classDeclaration.getName()));
		} else {
			classDeclaration.setInterfaceList(interfaces);
		}
	}
	classDeclaration.setEnd(interfacesright);
	classDeclaration.getBody().setStart(interfacesright);
	classDeclaration.getBody().setEnd(interfacesright);
:}
T_CURLY_OPEN:blockStart class_statement_list:statementList class_closure:blockEnd
{:
	if (blockEnd != null) {
		parser.reportError(new ASTError(statementListright - 1, statementListright), "syntax error, unfinished class declaration");
		parser.pendingStatement = blockEnd;
	}
	ClassDeclaration classDeclaration = (ClassDeclaration) parser.declarations.pop();
	classDeclaration.setRecovered(false);
	classDeclaration.setEnd(blockEndright);
	classDeclaration.getBody().setStart(blockStartleft);
	classDeclaration.getBody().setEnd(blockEndright);
	RESULT = classDeclaration;
:}

|
interface_entry:start T_STRING:className
interface_extends_list:interfaces
{:
	InterfaceDeclaration interfaceDeclaration = new InterfaceDeclaration(startleft, interfacesright, classNameleft, classNameright, className, interfaces, new Block(interfacesright, interfacesright, null), start);
	interfaceDeclaration.setRecovered(true);
	parser.declarations.push(interfaceDeclaration);
:}
T_CURLY_OPEN:blockStart class_statement_list:statementList class_closure:blockEnd
{:
	if (blockEnd != null) {
		parser.reportError(new ASTError(statementListright - 1, statementListright), "syntax error, unfinished class declaration");
		parser.pendingStatement = blockEnd;
	}

	InterfaceDeclaration interfaceDeclaration = (InterfaceDeclaration) parser.declarations.pop();
	interfaceDeclaration.setRecovered(false);
	interfaceDeclaration.setEnd(blockEndright);
	interfaceDeclaration.getBody().setStart(blockStartleft);
	interfaceDeclaration.getBody().setEnd(blockEndright);
	RESULT = interfaceDeclaration;
:}
;

errorOrNot ::=
error
|
;

/* Here go all elements that trigger the class closure */
class_closure ::=
T_CURLY_CLOSE /* normal behaviour */

/* error recovery - function declaration closes current class */
/* XXX: This is disabled for now because of lambda functions
function_declaration_statement:statement
{:
	RESULT = statement;
:}
*/

/* error recovery - another class declaration closes current class */
| class_declaration_statement:statement
{:
	RESULT = statement;
:}
;

class_entry_type ::=
T_CLASS:value
{:
	RESULT = parser.new ModifierDocPair(Modifiers.AccDefault, value.doc);
:}
| T_ABSTRACT:value T_CLASS
{:
	RESULT = parser.new ModifierDocPair(Modifiers.AccAbstract, value.doc);
:}
| T_FINAL:value T_CLASS
{:
	RESULT = parser.new ModifierDocPair(Modifiers.AccFinal, value.doc);
:}
| T_TRAIT:value
{:
	RESULT = parser.new ModifierDocPair(org.eclipse.php.core.compiler.IPHPModifiers.AccTrait, value.doc);
:}
;

extends_from ::=
/* empty */
{:
	RESULT = null;
:}
| T_EXTENDS fully_qualified_class_name:className
{:
	RESULT = className;
:}
| T_EXTENDS error:theError /* error recovery */
{:
	parser.reportError(new ASTError(theErrorleft, theErrorright));
:}
;

/* do nothing */
interface_entry ::=
T_INTERFACE:value
{:
	RESULT = value.doc;
:}
;

interface_extends_list ::=
/* empty */
{:
	List list = new LinkedList();
	RESULT = list;
:}
| T_EXTENDS interface_list:list
{:
	RESULT = list;
:}
;

implements_list ::=
/* empty */
{:
	List list = new LinkedList();
	RESULT = list;
:}

| T_IMPLEMENTS interface_list:list
{:
	RESULT = list;
:}
;

interface_list ::=
fully_qualified_class_name:className
{:
	List list = new LinkedList();
	if (className != null) {
		list.add(className);
	}
	RESULT = list;
:}

| interface_list:list T_COMMA fully_qualified_class_name:className
{:
	list.add(className);
	RESULT = list;
:}
| interface_list:list T_COMMA:comma error:theError /* error recovery */
{:
	parser.reportError(new ASTError(theErrorleft, theErrorright));
	RESULT = list;
:}
| error:theError
{:
	parser.reportError(new ASTError(theErrorleft, theErrorright));
	RESULT = new LinkedList();
:}
;

foreach_variable ::=
variable:var
{:
	RESULT = var;
:}

| T_REFERENCE:start variable:var
{:
	RESULT = new ReferenceExpression (startleft, varright, var);
:}

| T_LIST:start T_OPEN_PARENTHESE array_pair_list:list T_CLOSE_PARENTHESE:end
{:
	RESULT = new ListVariable(startleft, endright, list);
:}

| T_OPEN_RECT:start array_pair_list:list T_CLOSE_RECT:end
{:
	RESULT = new ArrayCreation(startleft, endright, list);
:}
;

for_statement ::=
statement:statement
{:
	RESULT = statement;
:}

| T_NEKUDOTAIM:start inner_statement_list:statementList T_ENDFOR T_SEMICOLON
{:
	RESULT = new Block(startleft, statementListright, statementList);
:}
;

foreach_statement ::=
statement:statement
{:
	RESULT = statement;
:}

| T_NEKUDOTAIM:start inner_statement_list:statementList T_ENDFOREACH T_SEMICOLON
{:
	RESULT = new Block(startleft, statementListright, statementList);
:}
;

declare_statement ::=
statement:statement
{:
	RESULT = statement;
:}

| T_NEKUDOTAIM:start inner_statement_list:statementList T_ENDDECLARE T_SEMICOLON
{:
	RESULT = new Block(startleft, statementListright, statementList);
:}
;

// this rule returns a pair of keys and values of directives to the declare statement
const_list ::=
string_st:constName T_EQUAL expr:expr
{:
	List listKeys = new LinkedList();
	List listValues = new LinkedList();

	listKeys.add(new ConstantReference(constNameleft, constNameright, constName));
	listValues.add(expr);

	RESULT = new List[] { listKeys, listValues };
:}

| const_list:lists T_COMMA string_st:constName T_EQUAL expr:expr
{:
	lists[0].add(new ConstantReference(constNameleft, constNameright, constName));
	lists[1].add(expr);
	RESULT = lists;
:}
;

switch_case_list ::=
T_CURLY_OPEN:start case_list:caseList T_CURLY_CLOSE:end
{:
	RESULT = new Block(startleft, endright, caseList);
:}

| T_CURLY_OPEN:start T_SEMICOLON case_list:caseList T_CURLY_CLOSE:end
{:
	RESULT = new Block(startleft, endright, caseList);
:}

| T_NEKUDOTAIM:start case_list:caseList T_ENDSWITCH T_SEMICOLON:end
{:
	RESULT = new Block(startleft, endright, caseList);
:}

| T_NEKUDOTAIM:start T_SEMICOLON case_list:caseList T_ENDSWITCH T_SEMICOLON:end
{:
	RESULT = new Block(startleft, endright, caseList);
:}
;

case_list ::=
/* empty */
{:
	RESULT = new LinkedList(); // of SwitchCase
:}

| case_list:caseList T_CASE:token expr:expr case_separator inner_statement_list:statements
{:
	SwitchCase switchCase = new SwitchCase(tokenleft, statementsright, expr, statements, false);
	if (caseList == null) {
		caseList = new LinkedList(); // of switchCase
	}
	caseList.add(switchCase);
	RESULT = caseList;
:}

| case_list:caseList T_DEFAULT:token case_separator inner_statement_list:statements
{:
	SwitchCase switchCase = new SwitchCase(tokenleft, statementsright, null, statements, true);
	if (caseList == null) {
		caseList = new LinkedList(); // of SwitchCase
	}
	caseList.add(switchCase);
	RESULT = caseList;
:}
;

/* Note: we don't capture seperator type */
case_separator ::=
T_NEKUDOTAIM
| T_SEMICOLON
;

while_statement ::=
statement:statement
{:
	RESULT = statement;
:}

| T_NEKUDOTAIM:colon inner_statement_list:statementList T_ENDWHILE T_SEMICOLON
{:
	Block block = new Block(colonleft, statementListright, statementList);
	RESULT = block;
:}
;

elseif_list ::=
/* empty */
{:
	List listConditions = new LinkedList();
	List listStatements = new LinkedList();
	List listTokens = new LinkedList();

	List[] returnList = new List[] { listConditions, listStatements, listTokens };

	RESULT = returnList;
:}

| elseif_list:elseifList T_ELSEIF:token T_OPEN_PARENTHESE expr:condition T_CLOSE_PARENTHESE statement:iftrue
{:
	((LinkedList) elseifList[0]).addFirst(condition);
	((LinkedList) elseifList[1]).addFirst(iftrue);
	((LinkedList) elseifList[2]).addFirst(Integer.valueOf(tokenleft));

	RESULT = elseifList;
:}
;

new_elseif_list ::=
/* empty */
{:
	List listConditions = new LinkedList();
	List listStatements = new LinkedList();
	List listTokens = new LinkedList();

	List[] returnList = new List[] { listConditions, listStatements, listTokens };

	RESULT = returnList;
:}

| new_elseif_list:elseifList T_ELSEIF:token T_OPEN_PARENTHESE expr:condition T_CLOSE_PARENTHESE T_NEKUDOTAIM:colon inner_statement_list:statementList
{:
	Block block = new Block(colonleft, statementListright, statementList);
	((LinkedList) elseifList[0]).addFirst(condition);
	((LinkedList) elseifList[1]).addFirst(block);
	((LinkedList) elseifList[2]).addFirst(Integer.valueOf(tokenleft));

	RESULT = elseifList;
:}
;

else_single ::=
/* empty */
{:
	RESULT = null;
:}

| T_ELSE statement:statement
{:
	RESULT = statement;
:}
;

new_else_single ::=
/* empty */
{:
	RESULT = null;
:}

| T_ELSE T_NEKUDOTAIM:colon inner_statement_list:statementList
{:
	Block block = new Block(colonleft, statementListright, statementList);
	RESULT = block;
:}
;

parameter_list ::=
non_empty_parameter_list:list
{:
	RESULT = list;
:}

| /* empty */
{:
	List list = new LinkedList();
	RESULT = list;
:}
;

non_empty_parameter_list ::=
parameter:parameter
{:
	List list = new LinkedList();
	if (parameter != null) {
		list.add(parameter);
	}
	RESULT = list;
:}

| non_empty_parameter_list:list T_COMMA parameter:parameter
{:
	if (parameter != null) {
		list.add(parameter);
	}

	if (list.size() >= 2) {
		FormalParameter previousFormalParameter = (FormalParameter) list.get(list.size() - 2);
		if (previousFormalParameter.isVariadic()) {
			parser.reportError(new ASTError(previousFormalParameter.start(), previousFormalParameter.end()), "Only the last parameter can be variadic");
		}
	}
	RESULT = list;
:}
| non_empty_parameter_list:list T_COMMA:comma /* error recovery */
{:
	parser.reportError(new ASTError(commaleft, commaright), "syntax error, unexpected ','");
	RESULT = list;
:}
;

parameter ::=
optional_class_type:classType T_VARIABLE:var
{:
	int start = classType == null ? varleft : classTypeleft;
	VariableReference v = new VariableReference(varleft, varright, var, PHPVariableKind.LOCAL);
	FormalParameter parameter = new FormalParameter(start, varright, classType, v);
	RESULT = parameter;
:}

| optional_class_type:classType T_ELLIPSIS:e T_VARIABLE:var
{:
	int start = classType == null ? eleft : classTypeleft;
	VariableReference v = new VariableReference(varleft, varright, var, PHPVariableKind.LOCAL);
	FormalParameter parameter = new FormalParameter(start, varright, classType, v, null, false, true);
	RESULT = parameter;
:}

| optional_class_type:classType T_REFERENCE:ref T_VARIABLE:var
{:
	int start = classType == null ? refleft : classTypeleft;
	VariableReference v = new VariableReference(varleft, varright, var, PHPVariableKind.LOCAL);
	FormalParameter parameter = new FormalParameterByReference(start, varright, classType, v);
	RESULT = parameter;
:}

| optional_class_type:classType T_REFERENCE:ref T_ELLIPSIS T_VARIABLE:var
{:
	int start = classType == null ? refleft : classTypeleft;
	VariableReference v = new VariableReference(varleft, varright, var, PHPVariableKind.LOCAL);
	FormalParameter parameter = new FormalParameterByReference(start, varright, classType, v, null, false, true);
	RESULT = parameter;
:}

| optional_class_type:classType T_VARIABLE:var T_EQUAL expr:expr
{:
	int start = classType == null ? varleft : classTypeleft;
	VariableReference v = new VariableReference(varleft, varright, var, PHPVariableKind.LOCAL);
	FormalParameter parameter = new FormalParameter(start, exprright, classType, v, expr);
	RESULT = parameter;
:}

| optional_class_type:classType T_REFERENCE:ref T_VARIABLE:var T_EQUAL expr:expr
{:
	int start = classType == null ? refleft : classTypeleft;
	VariableReference v = new VariableReference(varleft, varright, var, PHPVariableKind.LOCAL);
	FormalParameter parameter = new FormalParameterByReference(start, exprright, classType, v, expr);
	RESULT = parameter;
:}

| error:theError
{:
	parser.reportError(new ASTError(theErrorleft, theErrorright));
	RESULT = null;
:}
;

optional_class_type ::=
/* empty */
{:
	RESULT = null;
:}

| type_expr:type_expr
{:
	RESULT = type_expr;
:}
;

function_call_parameter_list ::=
non_empty_argument_list:paramsList possible_comma
{:
	RESULT = paramsList;
:}

| /* empty */
{:
	PHPCallArgumentsList list = new PHPCallArgumentsList();
	RESULT = list;
:}
;

non_empty_argument_list ::=
argument:argument
{:
	PHPCallArgumentsList paramsList = new PHPCallArgumentsList();
	paramsList.addNode(argument);
	RESULT = paramsList;
:}

| non_empty_argument_list:paramsList T_COMMA argument:var
{:
	paramsList.addNode(var);
	if (paramsList.getChilds().size() > 1) {
		ASTNode previousNode = paramsList.getChilds().get((paramsList.getChilds().size() - 2));
		if (!(var instanceof PrefixExpression) && previousNode instanceof PrefixExpression) {
			PrefixExpression pExpression = (PrefixExpression) previousNode;
			if (pExpression.getOperatorType() == PrefixExpression.OP_UNPACK) {
				parser.reportError(new ASTError(var.start(), var.end()), "Cannot use positional argument after argument unpacking");
			}
		}
	}
	RESULT = paramsList;
:}
;

argument ::=
expr:expr
{:
	RESULT = expr;
:}
| T_ELLIPSIS:ell expr:expr
{:
	RESULT = new PrefixExpression(ellleft, exprright, expr, PrefixExpression.OP_UNPACK);
:}
;

type_expr ::=
type:type
{:
	RESULT = type;
:}

| T_QUESTION_MARK type:type
{:
	type.setNullable(true);
	RESULT = type;
:}
;

type ::=
T_ARRAY:array
{:
	RESULT = new FullyQualifiedReference(arrayleft, arrayright, "array", null, FullyQualifiedReference.T_TYPE);
:}

| T_CALLABLE:callable
{:
	RESULT = new FullyQualifiedReference(callableleft, callableright, "callable", null, FullyQualifiedReference.T_TYPE);
:}

| name:name
{:
	name.setElementType(FullyQualifiedReference.T_TYPE);
	RESULT = name;
:}
;

return_type ::=
/* empty */
{:
	RESULT = null;
:}
| T_NEKUDOTAIM type_expr:type
{:
	RESULT = type;
:}
;

simple_variable_list ::=
simple_variable_list:list T_COMMA simple_variable:var
{:
	list.add(var);
	RESULT = list;
:}

| simple_variable:var
{:
	List list = new LinkedList();
	list.add(var);
	RESULT = list;
:}
;

simple_variable ::=
T_VARIABLE:var
{:
	VariableReference variable = new VariableReference(varleft, varright, var);
	RESULT = variable;
:}

| T_DOLLAR:start simple_variable:var
{:
	ReflectionVariableReference ref = new ReflectionVariableReference(startleft, varright, var);
	RESULT = ref;
:}

| T_DOLLAR:start T_CURLY_OPEN expr:varName T_CURLY_CLOSE:end
{:
	ReflectionVariableReference var = new ReflectionVariableReference(startleft, endright, varName);
	RESULT = var;
:}
;

static_var_list ::=
static_var:v
{:
	List list = new LinkedList();
	list.add(v);
	RESULT = list;
:}

| static_var_list:list T_COMMA static_var:v
{:
	list.add(v);
	RESULT = list;
:}
;

static_var ::=
T_VARIABLE:var
{:
	RESULT = new VariableReference(varleft, varright, var);
:}

| T_VARIABLE:var T_EQUAL expr:expr
{:
	VariableReference v = new VariableReference(varleft, varright, var);
	RESULT = new Assignment(varleft, exprright, v, Assignment.OP_EQUAL, expr);
:}
;

class_statement_list ::=
class_statement_list:list class_statement:classStatement
{:
	if (!(parser.declarations.peek() instanceof TypeDeclaration || parser.declarations.peek() instanceof AnonymousClassDeclaration)) {
		parser.declarations.pop();
	}
:}

| /* empty */
;

class_statement ::=
variable_modifiers:modifier property_list:decList T_SEMICOLON
{:
	Iterator i = decList.iterator();
	while (i.hasNext()) {
		ASTNode[] decl = (ASTNode[]) i.next();
		VariableReference variable = (VariableReference) decl[0];
		Expression initializer = (Expression) decl[1];
		int start = variable.sourceStart();
		int end = (initializer == null ? variable.sourceEnd() : initializer.sourceEnd());
		parser.addDeclarationStatement(new PHPFieldDeclaration(variable, initializer, start, end, modifier.modifier, modifierleft, modifier.doc));
	}
:}

| method_modifiers:modifier T_CONST:s class_const_list:lists T_SEMICOLON
{:
	int methodStart = modifier == null ? sleft : modifierleft;
	int modifierValue = modifier == null ? 0 : modifier.modifier;
	Iterator i = lists.iterator();
	PHPDocBlock docBlock = s.doc;
	if (modifier != null && modifier.doc != null) {
		docBlock = modifier.doc;
	}
	while (i.hasNext()) {
		ASTNode[] decl = (ASTNode[]) i.next();
		ConstantReference constant = (ConstantReference) decl[0];
		Expression initializer = (Expression) decl[1];

		int start = constant.sourceStart();
		int end = (initializer == null ? constant.sourceEnd() : initializer.sourceEnd());
		parser.addDeclarationStatement(new ConstantDeclaration(constant, initializer, modifierValue, methodStart, end, docBlock));
		docBlock = null;
	}
:}

| method_modifiers:modifier T_FUNCTION:start is_reference:isReference identifier:functionName
{:
	int methodStart = modifier == null ? startleft : modifierleft;
	int modifierValue = modifier == null ? Modifiers.AccPublic : modifier.modifier;
	PHPDocBlock docBlock = start.doc;
	if (modifier != null && modifier.doc != null) {
		docBlock = modifier.doc;
	}
	PHPMethodDeclaration methodDeclaration = new PHPMethodDeclaration(methodStart, functionNameright, functionNameleft, functionNameright, functionName, modifierValue, null, new Block(functionNameright, functionNameright, null), isReference.booleanValue(), docBlock);
	parser.addDeclarationStatement(methodDeclaration);
	parser.declarations.push(methodDeclaration);
:}
T_OPEN_PARENTHESE parameter_list:paramList T_CLOSE_PARENTHESE:closeParenthese
{:
	PHPMethodDeclaration functionDeclaration = (PHPMethodDeclaration) parser.declarations.peek();
	functionDeclaration.acceptArguments(paramList);
	functionDeclaration.setEnd(closeParentheseright);
:}
return_type:returnType
{:
	PHPMethodDeclaration functionDeclaration = (PHPMethodDeclaration) parser.declarations.peek();
	functionDeclaration.setReturnType(returnType);
:}
method_body:body
{:
	PHPMethodDeclaration methodDeclaration = (PHPMethodDeclaration) parser.declarations.pop();
	if (body instanceof ASTError) {
		parser.reportError(new ASTError(methodDeclaration.sourceEnd() - 1, methodDeclaration.sourceEnd()), "syntax error, unfinished method declaration");
	}
	if (parser.declarations.peek() instanceof TypeDeclaration) {
		TypeDeclaration type = (TypeDeclaration) parser.declarations.peek();
		methodDeclaration.setDeclaringTypeName(type.getName());
	}
	if (body instanceof EmptyStatement) { /* method without body part */
		Statement statement = parser.declarations.peek();
		if (statement instanceof ClassDeclaration) {
			ClassDeclaration classDeclaration = (ClassDeclaration) statement;
			if (classDeclaration.getModifiers() == org.eclipse.php.core.compiler.IPHPModifiers.AccTrait) { /* handle traits */
				if ((methodDeclaration.getModifiers() & Modifiers.AccAbstract) == 0) {
					parser.reportError(new ASTError(methodDeclaration.getNameStart(), methodDeclaration.getNameEnd(), PHPProblemIdentifier.MethodRequiresBody), Messages.MethodRequiresBody);
				}
			} else { /* handle classes */
				if ((classDeclaration.getModifiers() & Modifiers.AccAbstract) != 0) {
					if ((methodDeclaration.getModifiers() & Modifiers.AccAbstract) == 0) {
						parser.reportError(new ASTError(methodDeclaration.getNameStart(), methodDeclaration.getNameEnd(), PHPProblemIdentifier.MethodRequiresBody), Messages.MethodRequiresBody);
					}
				} else {
					if ((methodDeclaration.getModifiers() & Modifiers.AccAbstract) == 0) {
						parser.reportError(new ASTError(methodDeclaration.getNameStart(), methodDeclaration.getNameEnd(), PHPProblemIdentifier.MethodRequiresBody), Messages.MethodRequiresBody);
					} else {
						String message = Messages.getString("AbstractMethodInAbstractClass", methodDeclaration.getName(), classDeclaration.getName());
						parser.reportError(new ASTError(methodDeclaration.getNameStart(), methodDeclaration.getNameEnd(), PHPProblemIdentifier.AbstractMethodInAbstractClass), message);

						message = Messages.getString("AbstractMethodsInConcreteClass", classDeclaration.getName());
						parser.reportError(new ASTError(classDeclaration.getNameStart(), classDeclaration.getNameEnd(), PHPProblemIdentifier.AbstractMethodsInConcreteClass), message);
					}
				}
			}
		}
	} else if (body == null) { /* method with body part */
		Statement statement = parser.declarations.peek();
		if (statement instanceof ClassDeclaration) { /* handle classes and traits */
			if ((methodDeclaration.getModifiers() & Modifiers.AccAbstract) != 0) {
				ClassDeclaration classDeclaration = (ClassDeclaration) statement;
				parser.reportError(new ASTError(methodDeclaration.getNameStart(), methodDeclaration.getNameEnd(), PHPProblemIdentifier.BodyForAbstractMethod), Messages.BodyForAbstractMethod);

				if ((classDeclaration.getModifiers() & Modifiers.AccAbstract) == 0) {
					String message = Messages.getString("AbstractMethodInAbstractClass", methodDeclaration.getName(), classDeclaration.getName());
					parser.reportError(new ASTError(methodDeclaration.getNameStart(), methodDeclaration.getNameEnd(), PHPProblemIdentifier.AbstractMethodInAbstractClass), message);

					if (!(classDeclaration instanceof TraitDeclaration)) {
						message = Messages.getString("AbstractMethodsInConcreteClass", classDeclaration.getName());
						parser.reportError(new ASTError(classDeclaration.getNameStart(), classDeclaration.getNameEnd(), PHPProblemIdentifier.AbstractMethodsInConcreteClass), message);
					}
				}
			}
		} else if (statement instanceof InterfaceDeclaration) {
			parser.reportError(new ASTError(methodDeclaration.getNameStart(), methodDeclaration.getNameEnd(), PHPProblemIdentifier.BodyForAbstractMethod), Messages.BodyForAbstractMethod);
		}
	}
:}

| T_VAR_COMMENT
| error:theError /* error statement */
{:
	parser.reportError();
	ASTError error = new ASTError(theErrorleft, theErrorright);
	parser.addDeclarationStatement(error);
:}

| trait_use_statement:statement
{:
	RESULT = statement;
:}
;

trait_use_statement ::=
		T_USE:start trait_list:list trait_adaptations:adaptations
{:
	TraitUseStatement traitUseStatement = new TraitUseStatement(startleft, adaptationsright, list, adaptations);
	parser.addDeclarationStatement(traitUseStatement);
	parser.declarations.push(traitUseStatement);
	RESULT = traitUseStatement;
:}
;

trait_list ::=
		fully_qualified_class_name:name
{:
	List<TypeReference> traitList = new LinkedList<TypeReference>();
	traitList.add(name);
	RESULT = traitList;
:}
|	trait_list:traitList T_COMMA fully_qualified_class_name:name
{:
	traitList.add(name);
	RESULT = traitList;
:}
;

trait_adaptations ::=
		T_SEMICOLON
{:
	RESULT = null;
:}
|	T_CURLY_OPEN trait_adaptation_list:list T_CURLY_CLOSE
{:
	RESULT = list;
:}
;

trait_adaptation_list ::=
/* empty */
{:
	RESULT = null;
:}
|	non_empty_trait_adaptation_list:list
{:
	RESULT = list;
:}
;

non_empty_trait_adaptation_list ::=
		trait_adaptation_statement:statement
{:
	List<TraitStatement> taList = new LinkedList<TraitStatement>();
	taList.add(statement);
	RESULT = taList;
:}
|	non_empty_trait_adaptation_list:taList trait_adaptation_statement:statement
{:
	taList.add(statement);
	RESULT = taList;
:}
;

trait_adaptation_statement ::=
		trait_precedence:precedence T_SEMICOLON:end
{:
	TraitPrecedenceStatement traitPrecedenceStatement = new TraitPrecedenceStatement(precedenceleft, endright, precedence);
	RESULT = traitPrecedenceStatement;
:}
|	trait_alias:alias T_SEMICOLON:end
{:
	TraitAliasStatement traitAliasStatement = new TraitAliasStatement(aliasleft, endright, alias);
	RESULT = traitAliasStatement;
:}
;

trait_precedence ::=
	trait_method_reference_fully_qualified:methodReference T_INSTEADOF trait_reference_list:trList
{:
	TraitPrecedence traitPrecedence = new TraitPrecedence(methodReferenceleft, trListright, methodReference, trList);
	RESULT = traitPrecedence;
:}
;

trait_reference_list ::=
		fully_qualified_class_name:className
{:
	List<TypeReference> trList = new LinkedList<TypeReference>();
	trList.add(className);
	RESULT = trList;
:}
|	trait_reference_list:trList T_COMMA fully_qualified_class_name:className
{:
	trList.add(className);
	RESULT = trList;
:}
;

trait_method_reference ::=
T_STRING:functionName
{:
	SimpleReference name = new SimpleReference(functionNameleft, functionNameright, functionName);
	RESULT = name;
:}
| trait_method_reference_fully_qualified:className
{:
	RESULT = className;
:}
;

trait_method_reference_fully_qualified ::=
	fully_qualified_class_name:className T_PAAMAYIM_NEKUDOTAYIM T_STRING:functionName
{:
	SimpleReference name = new SimpleReference(functionNameleft, functionNameright, functionName);
	FullyQualifiedTraitMethodReference methodReference = new FullyQualifiedTraitMethodReference(classNameleft, functionNameright, className, functionName);
	RESULT = methodReference;
:}
;

trait_alias ::=
		trait_method_reference:reference T_AS trait_modifiers:modifier identifier:functionName
{:
	int modifierValue = modifier == null ? Modifiers.AccPublic : modifier.modifier;
	TraitAlias alias = new TraitAlias(reference, modifierValue,
		new SimpleReference(functionNameleft, functionNameright, functionName));
	RESULT = alias;
:}
|	trait_method_reference:reference T_AS non_empty_trait_modifiers:modifier
{:
	int modifierValue = modifier == null ? Modifiers.AccPublic : modifier.modifier;
	TraitAlias alias = new TraitAlias(reference, modifierValue, null);
	RESULT = alias;
:}
;

non_empty_trait_modifiers ::=
T_PUBLIC:value
{:
	RESULT = parser.new ModifierDocPair(Modifiers.AccPublic, value.doc);
:}

| T_PROTECTED:value
{:
	RESULT = parser.new ModifierDocPair(Modifiers.AccProtected, value.doc);
:}

| T_PRIVATE:value
{:
	RESULT = parser.new ModifierDocPair(Modifiers.AccPrivate, value.doc);
:}
;

trait_modifiers ::=
/* empty */
{:
	RESULT = null;
:}
| non_empty_trait_modifiers:modifier
{:
	RESULT = modifier;
:}
;

method_body ::=
T_SEMICOLON:end /* abstract method */
{:
	PHPMethodDeclaration methodDeclaration = (PHPMethodDeclaration) parser.declarations.peek();
	methodDeclaration.getBody().setStart(endleft);
	methodDeclaration.getBody().setEnd(endright);
	methodDeclaration.setEnd(endright);
	// return an EmptyStatement object to make distinction between an abstract method and a method with an empty body
	RESULT = new EmptyStatement(endleft, endright);
:}
| T_CURLY_OPEN:start inner_statement_list:statementList T_CURLY_CLOSE:end
{:
	PHPMethodDeclaration methodDeclaration = (PHPMethodDeclaration) parser.declarations.peek();
	methodDeclaration.getBody().setStart(startleft);
	methodDeclaration.getBody().setEnd(endright);
	methodDeclaration.getBody().getStatements().clear();
	methodDeclaration.getBody().acceptStatements(statementList);
	methodDeclaration.setEnd(endright);
	RESULT = null;
:}
| /* error recovery */
{:
	parser.reportError();
	RESULT = new ASTError(0, 0);
:}
;

variable_modifiers ::=
non_empty_member_modifiers:list
{:
	int result = 0;
	PHPDocBlock docBlock = null;
	for (Iterator it = list.iterator(); it.hasNext();) {
		CompilerAstParser.ModifierDocPair modifier = (CompilerAstParser.ModifierDocPair) it.next();
		if (modifier.doc != null) {
			docBlock = modifier.doc;
		}
		result = appendPropertyModifier(listleft, listright, result, modifier.modifier);
	}
	RESULT = parser.new ModifierDocPair(result, docBlock);
:}

| T_VAR:var
{:
	RESULT = parser.new ModifierDocPair(Modifiers.AccPublic, var.doc);
:}
;

method_modifiers ::=
/* empty */
{:
	RESULT = null;
:}

| non_empty_member_modifiers:list
{:
	int result = 0;
	PHPDocBlock docBlock = null;
	for (Iterator it = list.iterator(); it.hasNext();) {
		CompilerAstParser.ModifierDocPair modifier = (CompilerAstParser.ModifierDocPair) it.next();
		if (modifier.doc != null) {
			docBlock = modifier.doc;
		}
		result = appendMethodModifier(listleft, listright, result, modifier.modifier);
	}
	RESULT = parser.new ModifierDocPair(result, docBlock);
:}
;

non_empty_member_modifiers ::=
member_modifier:modifier
{:
	List list = new LinkedList();
	list.add(modifier);
	RESULT = list;
:}

| non_empty_member_modifiers:list member_modifier:modifier
{:
	list.add(modifier);
	RESULT = list;
:}
;

member_modifier ::=
T_PUBLIC:value
{:
	RESULT = parser.new ModifierDocPair(Modifiers.AccPublic, value.doc);
:}

| T_PROTECTED:value
{:
	RESULT = parser.new ModifierDocPair(Modifiers.AccProtected, value.doc);
:}

| T_PRIVATE:value
{:
	RESULT = parser.new ModifierDocPair(Modifiers.AccPrivate, value.doc);
:}

| T_STATIC:value
{:
	RESULT = parser.new ModifierDocPair(Modifiers.AccStatic, value.doc);
:}

| T_ABSTRACT:value
{:
	RESULT = parser.new ModifierDocPair(Modifiers.AccAbstract, value.doc);
:}

| T_FINAL:value
{:
	RESULT = parser.new ModifierDocPair(Modifiers.AccFinal, value.doc);
:}
;

property_list ::=
property_list:list T_COMMA T_VARIABLE:var
{:
	VariableReference varId = new VariableReference(varleft, varright, var);
	list.add(new ASTNode[] {varId, null});
	RESULT = list;
:}

| property_list:list T_COMMA T_VARIABLE:var T_EQUAL expr:expr
{:
	VariableReference varId = new VariableReference(varleft, varright, var);
	list.add(new ASTNode[] {varId, expr});
	RESULT = list;
:}

| T_VARIABLE:var
{:
	List list = new LinkedList();
	VariableReference varId = new VariableReference(varleft, varright, var);
	list.add(new ASTNode[] {varId, null});
	RESULT = list;
:}

| T_VARIABLE:var T_EQUAL expr:expr
{:
	List list = new LinkedList();
	VariableReference varId = new VariableReference(varleft, varright, var);
	list.add(new ASTNode[] {varId, expr});
	RESULT = list;
:}
;

non_empty_for_expr ::=
non_empty_for_expr:exprList T_COMMA expr:expr
{:
	exprList.add(expr);
	RESULT = exprList;
:}

| expr:expr
{:
	List exprList = new LinkedList();
	exprList.add(expr);
	RESULT = exprList;
:}
;

class_const_list ::=
class_const_list:list T_COMMA class_const_decl:decl
{:
	list.add(decl);
	RESULT = list;
:}

| class_const_decl:decl
{:
	List list = new LinkedList();
	list.add(decl);
	RESULT = list;
:}
;

class_const_decl ::=
identifier:constName T_EQUAL expr:expr
{:
	RESULT = new ASTNode[] { new ConstantReference(constNameleft, constNameright, constName), expr};
:}
;

echo_expr_list ::=
echo_expr_list:exprList T_COMMA expr:expr
{:
	exprList.add(expr);
	RESULT = exprList;
:}
| expr:expr
{:
	List exprList = new LinkedList();
	exprList.add(expr);
	RESULT = exprList;
:}
;

for_expr ::=
/* empty */
{:
	RESULT = new LinkedList();
:}

| non_empty_for_expr:exprList
{:
	RESULT = exprList;
:}
;

anonymous_class ::=
extends_from:superClass errorOrNot implements_list:interfaces
{:
	Block block = new Block(0, 0, null);
	AnonymousClassDeclaration acd = new AnonymousClassDeclaration(superClassleft, superClassleft, superClass, interfaces, block);
	acd.setRecovered(true);
	parser.addDeclarationStatement(acd);
	parser.declarations.push(acd);
:}
T_CURLY_OPEN:blockStart class_statement_list:statementList class_closure:blockEnd
{:
	AnonymousClassDeclaration acd = (AnonymousClassDeclaration) parser.declarations.pop();

	acd.setEnd(blockEndright);
	acd.setRecovered(false);
	acd.getBody().setStart(blockStartleft);
	acd.getBody().setEnd(blockEndright);
	RESULT = acd;
:}
;

new_expr ::=
T_NEW:start class_name_reference:className ctor_arguments:ctor
{:
	if (ctor.sourceStart() == 0) {
		ctor.setStart(classNameright);
		ctor.setEnd(classNameright);
	}
	ClassInstanceCreation classInstanceCreation = new ClassInstanceCreation(startleft, ctorright, className, ctor);
	RESULT = classInstanceCreation;
:}
| T_NEW:start T_CLASS:tclass ctor_arguments:ctor anonymous_class:ac
{:
	Expression className = new SimpleReference(tclassleft, tclassright, "class");
	RESULT = new ClassInstanceCreation(startleft, acright, className, ctor, ac);
:}
;

expr_without_variable ::=
T_LIST:start T_OPEN_PARENTHESE array_pair_list:list T_CLOSE_PARENTHESE:end T_EQUAL expr:expr
{:
	ListVariable listVariable = new ListVariable(startleft, endright, list);
	RESULT = new Assignment(startleft, exprright, listVariable, Assignment.OP_EQUAL, expr);
:}

| T_OPEN_RECT:start array_pair_list:list T_CLOSE_RECT:end T_EQUAL expr:expr
{:
	ArrayCreation arrayCreation = new ArrayCreation(startleft, endright, list);
	RESULT = new Assignment(startleft, exprright, arrayCreation, Assignment.OP_EQUAL, expr);
:}

| variable:var T_EQUAL expr:expr
{:
	RESULT = new Assignment(varleft, exprright, var, Assignment.OP_EQUAL, expr);
:}

| variable:var T_EQUAL T_REFERENCE:reftoken variable:refvar
{:
	RESULT = new Assignment(varleft, refvarright, var, Assignment.OP_REF_EQUAL, refvar);
:}

| T_CLONE:start expr:expr
{:
	RESULT = new CloneExpression(startleft, exprright, expr);
:}

| variable:var T_PLUS_EQUAL expr:expr
{:
	RESULT = new Assignment(varleft, exprright, var, Assignment.OP_PLUS_EQUAL, expr);
:}

| variable:var T_MINUS_EQUAL expr:expr
{:
	RESULT = new Assignment(varleft, exprright, var, Assignment.OP_MINUS_EQUAL, expr);
:}

| variable:var T_MUL_EQUAL expr:expr
{:
	RESULT = new Assignment(varleft, exprright, var, Assignment.OP_MUL_EQUAL, expr);
:}

| variable:var T_POW_EQUAL expr:expr
{:
	RESULT = new Assignment(varleft, exprright, var, Assignment.OP_POW_EQUAL, expr);
:}

| variable:var T_DIV_EQUAL expr:expr
{:
	RESULT = new Assignment(varleft, exprright, var, Assignment.OP_DIV_EQUAL, expr);
:}

| variable:var T_CONCAT_EQUAL expr:expr
{:
	RESULT = new Assignment(varleft, exprright, var, Assignment.OP_CONCAT_EQUAL, expr);
:}

| variable:var T_MOD_EQUAL expr:expr
{:
	RESULT = new Assignment(varleft, exprright, var, Assignment.OP_MOD_EQUAL, expr);
:}

| variable:var T_AND_EQUAL expr:expr
{:
	RESULT = new Assignment(varleft, exprright, var, Assignment.OP_AND_EQUAL, expr);
:}

| variable:var T_OR_EQUAL expr:expr
{:
	RESULT = new Assignment(varleft, exprright, var, Assignment.OP_OR_EQUAL, expr);
:}

| variable:var T_XOR_EQUAL expr:expr
{:
	RESULT = new Assignment(varleft, exprright, var, Assignment.OP_XOR_EQUAL, expr);
:}

| variable:var T_SL_EQUAL expr:expr
{:
	RESULT = new Assignment(varleft, exprright, var, Assignment.OP_SL_EQUAL, expr);
:}

| variable:var T_SR_EQUAL expr:expr
{:
	RESULT = new Assignment(varleft, exprright, var, Assignment.OP_SR_EQUAL, expr);
:}

| variable:var T_INC:token
{:
	RESULT = new PostfixExpression(varleft, tokenright, var, PostfixExpression.OP_INC);
:}

| T_INC:token variable:var
{:
	RESULT = new PrefixExpression(tokenleft, varright, var, PrefixExpression.OP_INC);
:}

| variable:var T_DEC:token
{:
	RESULT = new PostfixExpression(varleft, tokenright, var, PostfixExpression.OP_DEC);
:}

| T_DEC:token variable:var
{:
	RESULT = new PrefixExpression(tokenleft, varright, var, PrefixExpression.OP_DEC);
:}

| expr:expr1 T_BOOLEAN_OR expr:expr2
{:
	RESULT = new InfixExpression(expr1left, expr2right, expr1, InfixExpression.OP_BOOL_OR, expr2);
:}

| expr:expr1 T_BOOLEAN_AND expr:expr2
{:
	RESULT = new InfixExpression(expr1left, expr2right, expr1, InfixExpression.OP_BOOL_AND, expr2);
:}

| expr:expr1 T_LOGICAL_OR expr:expr2
{:
	RESULT = new InfixExpression(expr1left, expr2right, expr1, InfixExpression.OP_STRING_OR, expr2);
:}

| expr:expr1 T_LOGICAL_AND expr:expr2
{:
	RESULT = new InfixExpression(expr1left, expr2right, expr1, InfixExpression.OP_STRING_AND, expr2);
:}

| expr:expr1 T_LOGICAL_XOR expr:expr2
{:
	RESULT = new InfixExpression(expr1left, expr2right, expr1, InfixExpression.OP_STRING_XOR, expr2);
:}

| expr:expr1 T_OR expr:expr2
{:
	RESULT = new InfixExpression(expr1left, expr2right, expr1, InfixExpression.OP_OR, expr2);
:}

| expr:expr1 T_REFERENCE expr:expr2
{:
	RESULT = new InfixExpression(expr1left, expr2right, expr1, InfixExpression.OP_AND, expr2);
:}

| expr:expr1 T_KOVA expr:expr2
{:
	RESULT = new InfixExpression(expr1left, expr2right, expr1, InfixExpression.OP_XOR, expr2);
:}

| expr:expr1 T_NEKUDA expr:expr2
{:
	RESULT = new InfixExpression(expr1left, expr2right, expr1, InfixExpression.OP_CONCAT, expr2);
:}

| expr:expr1 T_PLUS expr:expr2
{:
	RESULT = new InfixExpression(expr1left, expr2right, expr1, InfixExpression.OP_PLUS, expr2);
:}

| expr:expr1 T_MINUS expr:expr2
{:
	RESULT = new InfixExpression(expr1left, expr2right, expr1, InfixExpression.OP_MINUS, expr2);
:}

| expr:expr1 T_TIMES expr:expr2
{:
	RESULT = new InfixExpression(expr1left, expr2right, expr1, InfixExpression.OP_MUL, expr2);
:}

| expr:expr1 T_POW expr:expr2
{:
	RESULT = new InfixExpression(expr1left, expr2right, expr1, InfixExpression.OP_POW, expr2);
:}

| expr:expr1 T_DIV expr:expr2
{:
	RESULT = new InfixExpression(expr1left, expr2right, expr1, InfixExpression.OP_DIV, expr2);
:}

| expr:expr1 T_PRECENT expr:expr2
{:
	RESULT = new InfixExpression(expr1left, expr2right, expr1, InfixExpression.OP_MOD, expr2);
:}

| expr:expr1 T_SL expr:expr2
{:
	RESULT = new InfixExpression(expr1left, expr2right, expr1, InfixExpression.OP_SL, expr2);
:}

| expr:expr1 T_SR expr:expr2
{:
	RESULT = new InfixExpression(expr1left, expr2right, expr1, InfixExpression.OP_SR, expr2);
:}

| T_PLUS:token expr:expr
{:
	RESULT = new UnaryOperation(tokenleft, exprright, expr, UnaryOperation.OP_PLUS);
:}

| T_MINUS:token expr:expr
{:
	RESULT = new UnaryOperation(tokenleft, exprright, expr, UnaryOperation.OP_MINUS);
:}

| T_NOT:token expr:expr
{:
	RESULT = new UnaryOperation(tokenleft, exprright, expr, UnaryOperation.OP_NOT);
:}

| T_TILDA:token expr:expr
{:
	RESULT = new UnaryOperation(tokenleft, exprright, expr, UnaryOperation.OP_TILDA);
:}

| expr:expr1 T_IS_IDENTICAL expr:expr2
{:
	RESULT = new InfixExpression(expr1left, expr2right, expr1, InfixExpression.OP_IS_IDENTICAL, expr2);
:}

| expr:expr1 T_IS_NOT_IDENTICAL expr:expr2
{:
	RESULT = new InfixExpression(expr1left, expr2right, expr1, InfixExpression.OP_IS_NOT_IDENTICAL, expr2);
:}

| expr:expr1 T_IS_EQUAL expr:expr2
{:
	RESULT = new InfixExpression(expr1left, expr2right, expr1, InfixExpression.OP_IS_EQUAL, expr2);
:}

| expr:expr1 T_IS_NOT_EQUAL expr:expr2
{:
	RESULT = new InfixExpression(expr1left, expr2right, expr1, InfixExpression.OP_IS_NOT_EQUAL, expr2);
:}

| expr:expr1 T_RGREATER expr:expr2
{:
	RESULT = new InfixExpression(expr1left, expr2right, expr1, InfixExpression.OP_RGREATER, expr2);
:}

| expr:expr1 T_IS_SMALLER_OR_EQUAL expr:expr2
{:
	RESULT = new InfixExpression(expr1left, expr2right, expr1, InfixExpression.OP_IS_SMALLER_OR_EQUAL, expr2);
:}

| expr:expr1 T_LGREATER expr:expr2
{:
	RESULT = new InfixExpression(expr1left, expr2right, expr1, InfixExpression.OP_LGREATER, expr2);
:}

| expr:expr1 T_IS_GREATER_OR_EQUAL expr:expr2
{:
	RESULT = new InfixExpression(expr1left, expr2right, expr1, InfixExpression.OP_IS_GREATER_OR_EQUAL, expr2);
:}

| expr:expr1 T_SPACESHIP expr:expr2
{:
	RESULT = new InfixExpression(expr1left, expr2right, expr1, InfixExpression.OP_SPACESHIP, expr2);
:}

| expr:expr T_INSTANCEOF class_name_reference:className
{:
	RESULT = new InstanceOfExpression(exprleft, classNameright, expr, className);
:}

| T_OPEN_PARENTHESE:start expr:expr T_CLOSE_PARENTHESE:end
{:
	RESULT = expr;
:}

| new_expr:expr
{:
	RESULT = expr;
:}

| yield_expr:yield
{:
	boolean found = false;
	ListIterator<Statement> it = parser.declarations.listIterator(parser.declarations.size());
	while (!found && it.hasPrevious()) {
		Statement prev = it.previous();
		found = (prev instanceof PHPMethodDeclaration) || (prev instanceof LambdaFunctionDeclaration);
	}
	if (parser.declarations.isEmpty() || !found) {
		parser.reportError(new ASTError(yieldleft, yieldright), "syntax error, the yield expression can only be used inside a function");
		parser.pendingStatement = yield;
	}
	RESULT = yield;
:}

| expr:condition T_QUESTION_MARK expr:ifTrue T_NEKUDOTAIM expr:ifFalse
{:
	RESULT = new ConditionalExpression(conditionleft, ifFalseright, condition, ifTrue, ifFalse);
:}

| expr:condition T_QUESTION_MARK T_NEKUDOTAIM expr:ifFalse
{:
	RESULT = new ConditionalExpression(conditionleft, ifFalseright, condition, null, ifFalse);
:}

| expr:expr1 T_COALESCE expr:expr2
{:
	RESULT = new ConditionalExpression(expr1left, expr2right, expr1, expr2);
:}

| internal_functions_in_yacc:expr
{:
	RESULT = expr;
:}

| T_INT_CAST:token expr:expr
{:
	RESULT = new CastExpression(tokenleft, exprright, expr, CastExpression.TYPE_INT);
:}

| T_DOUBLE_CAST:token expr:expr
{:
	RESULT = new CastExpression(tokenleft, exprright, expr, CastExpression.TYPE_REAL);
:}

| T_STRING_CAST:token expr:expr
{:
	RESULT = new CastExpression(tokenleft, exprright, expr, CastExpression.TYPE_STRING);
:}

| T_ARRAY_CAST:token expr:expr
{:
	RESULT = new CastExpression(tokenleft, exprright, expr, CastExpression.TYPE_ARRAY);
:}

| T_OBJECT_CAST:token expr:expr
{:
	RESULT = new CastExpression(tokenleft, exprright, expr, CastExpression.TYPE_OBJECT);
:}

| T_BOOL_CAST:token expr:expr
{:
	RESULT = new CastExpression(tokenleft, exprright, expr, CastExpression.TYPE_BOOL);
:}

| T_UNSET_CAST:token expr:expr
{:
	RESULT = new CastExpression(tokenleft, exprright, expr, CastExpression.TYPE_UNSET);
:}

| T_EXIT:start exit_expr:expr
{:
	PHPCallArgumentsList list = new PHPCallArgumentsList();
	if (expr != null) {
		list.addNode(expr);
		list.setStart(expr.sourceStart());
		list.setEnd(expr.sourceEnd());
	} else {
		list.setStart(startright);
		list.setEnd(startright);
	}
	SimpleReference functionName = new SimpleReference(startleft, startright, start);
	PHPCallExpression result = new PHPCallExpression(startleft, exprright, null, functionName, list);
	RESULT = result;
:}

| T_AT:start expr:expr
{:
	IgnoreError ignoreError = new IgnoreError(startleft, exprright, expr);
	RESULT = ignoreError;
:}

| scalar:scalar
{:
	RESULT = scalar;
:}

| T_BACKQUATE:start backticks_expr:list T_BACKQUATE:end
{:
	BackTickExpression backTickExpression = new BackTickExpression(startleft, endright, list);
	RESULT = backTickExpression;
:}

| T_PRINT:start expr:expr
{:
	PHPCallArgumentsList list = new PHPCallArgumentsList();
	if (expr != null) {
		list.addNode(expr);
		list.setStart(expr.sourceStart());
		list.setEnd(expr.sourceEnd());
	} else {
		list.setStart(startright);
		list.setEnd(startright);
	}
	SimpleReference name = new SimpleReference(startleft, startright, "print");
	PHPCallExpression result = new PHPCallExpression(startleft, exprright, null, name, list);
	RESULT = result;
:}

| T_FUNCTION:s is_reference:isReference
T_OPEN_PARENTHESE parameter_list:paramList T_CLOSE_PARENTHESE lexical_vars:varsList return_type:returnType
{:
	LambdaFunctionDeclaration functionDeclaration = new LambdaFunctionDeclaration(sleft, varsListright, paramList, varsList,
		null, isReference.booleanValue(), false, returnType);
	parser.addDeclarationStatement(functionDeclaration);
	parser.declarations.push(functionDeclaration);
:}
lambda_function_body:body
{:
	RESULT = body;
:}
| T_STATIC:modifier T_FUNCTION:s is_reference:isReference
T_OPEN_PARENTHESE parameter_list:paramList T_CLOSE_PARENTHESE lexical_vars:varsList return_type:returnType
{:
	LambdaFunctionDeclaration functionDeclaration = new LambdaFunctionDeclaration(modifierleft, varsListright, paramList, varsList,
		null, isReference.booleanValue(), true, returnType);
	parser.addDeclarationStatement(functionDeclaration);
	parser.declarations.push(functionDeclaration);
:}
lambda_function_body:body
{:
	RESULT = body;
:}
;

lambda_function_body ::=
T_CURLY_OPEN:blockStart inner_statement_list:statementList T_CURLY_CLOSE:blockEnd
{:
	LambdaFunctionDeclaration functionDeclaration = (LambdaFunctionDeclaration) parser.declarations.pop();
	Block block = new Block(blockStartleft, blockEndright, statementList);
	functionDeclaration.setBody(block);
	functionDeclaration.setEnd(blockEndright);
	RESULT = functionDeclaration;
:}
| error:theError
{:
	RESULT = (LambdaFunctionDeclaration) parser.declarations.pop();
:}
;

lexical_vars ::=
/* empty */
{:
	RESULT = null;
:}

| T_USE:s T_OPEN_PARENTHESE lexical_var_list:list T_CLOSE_PARENTHESE:e
{:
	RESULT = list;
:}
;

lexical_var_list ::=
lexical_var_list:list T_COMMA lexical_var:var
{:
	list.add(var);
	RESULT = list;
:}

| lexical_var:var
{:
	List list = new LinkedList();
	list.add(var);
	RESULT = list;
:}
;

lexical_var ::=
T_VARIABLE:var
{:
	RESULT = new VariableReference(varleft, varright, var);
:}

| T_REFERENCE:ref T_VARIABLE:var
{:
	RESULT = new ReferenceExpression(refleft, varright, new VariableReference(varleft, varright, var));
:}
;

function_call ::=
name:functionName T_OPEN_PARENTHESE:start function_call_parameter_list:parameters T_CLOSE_PARENTHESE:end
{:
	parameters.setStart(startright);
	parameters.setEnd(endleft);
	functionName.setElementType(FullyQualifiedReference.T_FUNCTION);
	RESULT = new PHPCallExpression(functionNameleft, endright, null, functionName, parameters);
:}

| class_name:className T_PAAMAYIM_NEKUDOTAYIM member_name:functionName T_OPEN_PARENTHESE:start function_call_parameter_list:parameters T_CLOSE_PARENTHESE:end
{:
	parameters.setStart(startright);
	parameters.setEnd(endleft);
	if (functionName.getClass() == SimpleReference.class) {
		RESULT = new StaticMethodInvocation(classNameleft, endright, className, functionName, (SimpleReference) functionName, parameters);
	}else{
		RESULT = new ReflectionStaticMethodInvocation(classNameleft, endright, className, functionName, parameters);
	}

:}

| variable_class_name:className T_PAAMAYIM_NEKUDOTAYIM member_name:reflectionName T_OPEN_PARENTHESE:start function_call_parameter_list:parameters T_CLOSE_PARENTHESE:end
{:
	parameters.setStart(startright);
	parameters.setEnd(endleft);
	ReflectionStaticMethodInvocation functionInvocation = new ReflectionStaticMethodInvocation(classNameleft, endright, className, reflectionName, parameters);
	RESULT = functionInvocation;
:}

| callable_expr:reflectionName T_OPEN_PARENTHESE:start function_call_parameter_list:parameters T_CLOSE_PARENTHESE:end
{:
	parameters.setStart(startright);
	parameters.setEnd(endleft);
	RESULT = new ReflectionCallExpression(reflectionNameleft, endright, null, reflectionName, parameters);
:}
;

class_name ::=
T_STATIC:s
{:
	RESULT = new FullyQualifiedReference(sleft, sright, "static", null, FullyQualifiedReference.T_TYPE);
:}

| name:name
{:
	name.setElementType(FullyQualifiedReference.T_TYPE);
	RESULT = name;
:}
;

fully_qualified_class_name ::=
namespace_name:name
{:
	name.setElementType(FullyQualifiedReference.T_TYPE);
	RESULT = name;
:}

| T_NAMESPACE:s T_NS_SEPARATOR namespace_name:name
{:
	if (name.getNamespace() == null) {
		name.setNamespace(new NamespaceReference(nameleft, nameleft, ""));
	}

	name.getNamespace().setLocal(true);
	name.setElementType(FullyQualifiedReference.T_TYPE);
	RESULT = name;
:}

| T_NS_SEPARATOR:s namespace_name:name
{:
	NamespaceReference namespace = name.getNamespace();
	if (namespace == null) {
		namespace = new NamespaceReference(sleft, sright, "");
		name.setNamespace(namespace);
	}
	namespace.setGlobal(true);
	namespace.setStart(sleft);
	name.setStart(sleft);
	name.setElementType(FullyQualifiedReference.T_TYPE);
	RESULT = name;
:}
;

class_name_reference ::=
class_name:className
{:
	RESULT = className;
:}

| new_variable:className
{:
	RESULT = className;
:}
;

exit_expr ::=
/* empty */
{:
	RESULT = null;
:}

| T_OPEN_PARENTHESE T_CLOSE_PARENTHESE
{:
	RESULT = null;
:}

| T_OPEN_PARENTHESE expr:expr T_CLOSE_PARENTHESE
{:
	RESULT = expr;
:}
;

backticks_expr ::=
/* empty */
{:
	RESULT = new LinkedList();
:}

| T_ENCAPSED_AND_WHITESPACE:string
{:
	List list = new LinkedList();
	Scalar scalar = new Scalar(stringleft, stringright, string == null ? "" : string, string == null ? Scalar.TYPE_UNKNOWN : Scalar.TYPE_STRING);
	list.add(scalar);
	RESULT = list;
:}

| encaps_list:list
{:
	RESULT = list;
:}
;

ctor_arguments ::=
/* empty */
{:
	RESULT = new PHPCallArgumentsList();
:}

| T_OPEN_PARENTHESE:start function_call_parameter_list:paramsList T_CLOSE_PARENTHESE:end
{:
	paramsList.setStart(startright);
	paramsList.setEnd(endleft);
	RESULT = paramsList;
:}
;

scalar ::=
T_LNUMBER:scalar
{:
	Scalar s = new Scalar(scalarleft, scalarright, scalar, Scalar.TYPE_INT);
	RESULT = s;
:}

| T_DNUMBER:scalar
{:
	Scalar s = new Scalar(scalarleft, scalarright, scalar, Scalar.TYPE_REAL);
	RESULT = s;
:}

| T_BNUMBER:scalar
{:
	Scalar s = new Scalar(scalarleft, scalarright, scalar, Scalar.TYPE_BIN);
	RESULT = s;
:}

| T_LINE:scalar
{:
	Scalar s = new Scalar(scalarleft, scalarright, "__LINE__", Scalar.TYPE_SYSTEM);
	RESULT = s;
:}

| T_FILE:scalar
{:
	Scalar s = new Scalar(scalarleft, scalarright, "__FILE__", Scalar.TYPE_SYSTEM);
	RESULT = s;
:}

| T_DIR:scalar
{:
	Scalar s = new Scalar(scalarleft, scalarright, "__DIR__", Scalar.TYPE_SYSTEM);
	RESULT = s;
:}

| T_CLASS_C:scalar
{:
	Scalar s = new Scalar(scalarleft, scalarright, "__CLASS__", Scalar.TYPE_SYSTEM);
	RESULT = s;
:}

| T_TRAIT_C:scalar
{:
	Scalar s = new Scalar(scalarleft, scalarright, "__TRAIT__", Scalar.TYPE_SYSTEM);
	RESULT = s;
:}

| T_METHOD_C:scalar
{:
	Scalar s = new Scalar(scalarleft, scalarright, "__METHOD__", Scalar.TYPE_SYSTEM);
	RESULT = s;
:}

| T_FUNC_C:scalar
{:
	Scalar s = new Scalar(scalarleft, scalarright, "__FUNCTION__", Scalar.TYPE_SYSTEM);
	RESULT = s;
:}

| T_NS_C:scalar
{:
	RESULT = new Scalar(scalarleft, scalarright, "__NAMESPACE__", Scalar.TYPE_SYSTEM);
:}

| T_START_HEREDOC:label T_ENCAPSED_AND_WHITESPACE:string T_END_HEREDOC:e
{:
	List list = new LinkedList();
	list.add(new Scalar(stringleft, stringright, string == null ? "" : string, string == null ? Scalar.TYPE_UNKNOWN : Scalar.TYPE_STRING));
	RESULT = new Quote(labelleft, eright, list, label.charAt(0) == '\'' ? Quote.QT_NOWDOC : Quote.QT_HEREDOC);
:}

| T_START_HEREDOC:label T_END_HEREDOC:e
{:
	RESULT = new Quote(labelleft, eright, new LinkedList(), label.charAt(0) == '\'' ? Quote.QT_NOWDOC : Quote.QT_HEREDOC);
:}

| T_QUATE:start encaps_list:list T_QUATE:end
{:
	RESULT = new Quote(startleft, endright, list, Quote.QT_QUOTE);
:}
| T_SINGLE_QUATE:start encaps_list:list T_SINGLE_QUATE:end
{:
	RESULT = new Quote(startleft, endright, list, Quote.QT_SINGLE);
:}
| T_START_HEREDOC:start encaps_list:list T_END_HEREDOC:end
{:
	Quote hereDoc = new Quote(startleft, endright, list, Quote.QT_HEREDOC);
	RESULT = hereDoc;
:}

| dereferencable_scalar:name
{:
	RESULT = name;
:}

| constant:classConstant
{:
	RESULT = classConstant;
:}
;

/* do nothing */
possible_comma ::=
/* empty */
| T_COMMA
;

expr ::=
variable:var
{: RESULT = var; :}

| expr_without_variable:ewv
{: RESULT = ewv; :}
;

variable ::=
callable_variable:var
{:
	RESULT = var;
:}
| static_member:s
{:
	RESULT = s;
:}

| dereferencable:dispatch T_OBJECT_OPERATOR property_name:property
{:
	RESULT = new FieldAccess(dispatchleft, propertyright, dispatch, property);
:}
;

dereferencable ::=
variable:v
{:
	RESULT = v;
:}
| T_OPEN_PARENTHESE:s expr:expr T_CLOSE_PARENTHESE:e
{:
	RESULT = expr;
:}

| dereferencable_scalar:s
{:
	RESULT = s;
:}
;

callable_expr ::=
callable_variable:v
{:
	RESULT = v;
:}
| T_OPEN_PARENTHESE expr:expr T_CLOSE_PARENTHESE
{:
	RESULT = expr;
:}

| dereferencable_scalar:s
{:
	RESULT = s;
:}
;

dereferencable_scalar ::=
T_ARRAY:start T_OPEN_PARENTHESE array_pair_list:list T_CLOSE_PARENTHESE:end
{:
	RESULT = new ArrayCreation(startleft, endright, list);
:}

| T_OPEN_RECT:start array_pair_list:list T_CLOSE_RECT:end
{:
	RESULT = new ArrayCreation(startleft, endright, list);
:}

| T_CONSTANT_ENCAPSED_STRING:scalar
{:
	RESULT = new Scalar(scalarleft, scalarright, scalar, Scalar.TYPE_STRING);
:}
;

callable_variable ::=
simple_variable:var
{:
	RESULT = var;
:}
| dereferencable:d T_OPEN_RECT:f optional_expr:dim T_CLOSE_RECT:e
{:
	if (d.getClass() == VariableReference.class) {
		RESULT = new ArrayVariableReference(dleft, eright, ((VariableReference) d).getName(), dim, ArrayVariableReference.VARIABLE_ARRAY);
	} else {
		RESULT = new ReflectionArrayVariableReference(dleft, eright, d, dim, ReflectionArrayVariableReference.VARIABLE_ARRAY);
	}
:}

| constant:d T_OPEN_RECT:f optional_expr:dim T_CLOSE_RECT:e
{:
	RESULT = new ReflectionArrayVariableReference(dleft, eright, d, dim, ReflectionArrayVariableReference.VARIABLE_ARRAY);
:}

| dereferencable:d T_CURLY_OPEN expr:dim T_CURLY_CLOSE:e
{:
	if (d.getClass() == VariableReference.class) {
		RESULT = new ArrayVariableReference(dleft, eright, ((VariableReference) d).getName(), dim, ArrayVariableReference.VARIABLE_HASHTABLE);
	} else {
		RESULT = new ReflectionArrayVariableReference(dleft, eright, d, dim, ReflectionArrayVariableReference.VARIABLE_HASHTABLE);
	}
:}

| dereferencable:ch T_OBJECT_OPERATOR property_name:memberProperty T_OPEN_PARENTHESE:start function_call_parameter_list:paramsList T_CLOSE_PARENTHESE:end
{:
	paramsList.setStart(startright);
	paramsList.setEnd(endleft);
	if (memberProperty.getClass() == SimpleReference.class) {
		RESULT = new PHPCallExpression(chleft, endright, ch, (SimpleReference) memberProperty, paramsList);
	} else {
		RESULT = new ReflectionCallExpression(chleft, endright, ch, memberProperty, paramsList);
	}
:}
| function_call:c
{:
	RESULT = c;
:}
;

constant ::=
name:name
{:
	RESULT = detectScalar(name);
:}
| class_name:className T_PAAMAYIM_NEKUDOTAYIM identifier:var
{:
	RESULT = new StaticConstantAccess(classNameleft, varright, className, new ConstantReference(varleft, varright, var));
:}

| variable_class_name:className T_PAAMAYIM_NEKUDOTAYIM identifier:var
{:
	RESULT = new StaticConstantAccess(classNameleft, varright, className, new ConstantReference(varleft, varright, var));
:}
;

static_member ::=
class_name:className T_PAAMAYIM_NEKUDOTAYIM simple_variable:var
{:
	RESULT = new StaticFieldAccess(classNameleft, varright, className, var);
:}

| variable_class_name:className T_PAAMAYIM_NEKUDOTAYIM simple_variable:var
{:
	RESULT = new StaticFieldAccess(classNameleft, varright, className, var);
:}
;

new_variable ::=
simple_variable:v
{:
	RESULT = v;
:}

| new_variable:varName T_OPEN_RECT optional_expr:index T_CLOSE_RECT:e
{:
	if (varName.getClass() == VariableReference.class) {
		RESULT = new ArrayVariableReference(varNameleft, eright, ((VariableReference) varName).getName(), index, ArrayVariableReference.VARIABLE_ARRAY);
	} else {
		RESULT = new ReflectionArrayVariableReference(varNameleft, eright, varName, index, ReflectionArrayVariableReference.VARIABLE_ARRAY);
	}
:}

| new_variable:varName T_CURLY_OPEN expr:index T_CURLY_CLOSE:e
{:
	if (varName.getClass() == VariableReference.class) {
		RESULT = new ArrayVariableReference(varNameleft, eright, ((VariableReference) varName).getName(), index, ArrayVariableReference.VARIABLE_HASHTABLE);
	} else {
		RESULT = new ReflectionArrayVariableReference(varNameleft, eright, varName, index, ReflectionArrayVariableReference.VARIABLE_HASHTABLE);
	}
:}

| new_variable:dispatcher T_OBJECT_OPERATOR property_name:property
{:
	RESULT = new FieldAccess(dispatcherleft, propertyright, dispatcher, property);
:}

| class_name:className T_PAAMAYIM_NEKUDOTAYIM simple_variable:var
{:
	RESULT = new StaticFieldAccess(classNameleft, varright, className, var);
:}

| new_variable:className T_PAAMAYIM_NEKUDOTAYIM simple_variable:var
{:
	RESULT = new StaticFieldAccess(classNameleft, varright, className, var);
:}
;

variable_class_name ::=
dereferencable:var
{:
	RESULT = var;
:}
;

optional_expr ::=
/* empty */
{:
	RESULT = null;
:}

| expr:expr
{:
	RESULT = expr;
:}
;

member_name ::=
identifier:varName
{:
	RESULT = new SimpleReference(varNameleft, varNameright, varName);
:}

| T_CURLY_OPEN:start expr:expr T_CURLY_CLOSE:end
{:
	RESULT = new ReflectionVariableReference(startleft, endright, expr);
:}

| simple_variable:v
{:
	RESULT = v;
:}
;

property_name ::=
string_st:varName
{:
	RESULT = new SimpleReference(varNameleft, varNameright, varName);
:}

| T_CURLY_OPEN:start expr:expr T_CURLY_CLOSE:end
{:
	RESULT = new ReflectionVariableReference(startleft, endright, expr);
:}

| simple_variable:v
{:
	RESULT = v;
:}
;

array_pair_list ::=
non_empty_array_pair_list:list
{:
	RESULT = list;
:}
;

possible_array_pair ::=
/* empty */
{:
	RESULT = null;
:}

| array_pair:pair
{:
	RESULT = pair;
:}
;

non_empty_array_pair_list ::=
possible_array_pair:pair
{:
	List list = new LinkedList();
	if (pair != null) {
		list.add(pair);
	}
	RESULT = list;
:}

| non_empty_array_pair_list:list T_COMMA possible_array_pair:pair
{:
	if (pair != null) {
		list.add(pair);
	}
	RESULT = list;
:}
;

array_pair ::=
expr:key T_DOUBLE_ARROW expr:value
{:
	RESULT = new ArrayElement(keyleft, valueright, key, value);
:}

| expr:expr
{:
	RESULT = expr;
:}

| expr:key T_DOUBLE_ARROW T_REFERENCE:start variable:var
{:
	ReferenceExpression value = new ReferenceExpression(startleft, varright, var);
	RESULT = new ArrayElement(keyleft, varright, key, value);
:}

| T_REFERENCE:start variable:var
{:
	RESULT = new ReferenceExpression(startleft, varright, var);
:}

| expr:key T_DOUBLE_ARROW T_LIST:s T_OPEN_PARENTHESE array_pair_list:list T_CLOSE_PARENTHESE:e
{:
	ListVariable value = new ListVariable(sleft, eright, list);
	RESULT = new ArrayElement(keyleft, eright, key, value);
:}

| T_LIST:s T_OPEN_PARENTHESE array_pair_list:list T_CLOSE_PARENTHESE:e
{:
	RESULT = new ListVariable(sleft, eright, list);
:}
;

encaps_list ::=
encaps_list:list encaps_var:var
{:
	list.add(var);
	RESULT = list;
:}

| encaps_list:list T_ENCAPSED_AND_WHITESPACE:string
{:
	Scalar scalar = new Scalar(stringleft, stringright, string == null ? "" : string, string == null ? Scalar.TYPE_UNKNOWN : Scalar.TYPE_STRING);
	list.add(scalar);
	RESULT = list;
:}

| encaps_list:list T_CHARACTER:string
{:
	Scalar scalar = new Scalar(stringleft, stringright, string, Scalar.TYPE_STRING);
	list.add(scalar);
	RESULT = list;
:}

| encaps_var:var
{:
	List list = new LinkedList();
	list.add(var);
	RESULT = list;
:}

| T_ENCAPSED_AND_WHITESPACE:string encaps_var:var
{:
	List list = new LinkedList();
	Scalar scalar = new Scalar(stringleft, stringright, string == null ? "" : string, string == null ? Scalar.TYPE_UNKNOWN : Scalar.TYPE_STRING);
	list.add(scalar);
	list.add(var);
	RESULT = list;
:}
;

encaps_var ::=
T_CURLY_OPEN_WITH_DOLAR:start variable:var T_CURLY_CLOSE:end
{:
	ReflectionVariableReference ref = new ReflectionVariableReference(startleft, endright, var);
	RESULT = ref;
:}

| T_VARIABLE:varName
{:
	RESULT = new VariableReference(varNameleft, varNameright, varName, PHPVariableKind.LOCAL);
:}

| T_VARIABLE:varName T_OPEN_RECT encaps_var_offset:index T_CLOSE_RECT:end
{:
	RESULT = new ArrayVariableReference(varNameleft, endright, varName, index, ArrayVariableReference.VARIABLE_ARRAY);
:}

| T_VARIABLE:varName T_OBJECT_OPERATOR string_st:string
{:
	RESULT = new FieldAccess(varNameleft, stringright, new VariableReference(varNameleft, varNameright, varName, PHPVariableKind.LOCAL), new SimpleReference(stringleft, stringright, string));
:}

| T_DOLLAR_OPEN_CURLY_BRACES:start expr:expr T_CURLY_CLOSE:end
{:
	RESULT = new ReflectionVariableReference(startleft, endright, expr);
:}

| T_DOLLAR_OPEN_CURLY_BRACES:start T_STRING_VARNAME:varName T_CURLY_CLOSE:end
{:
	RESULT = new ReflectionVariableReference(startleft, endright, new Scalar(varNameleft, varNameright, varName, Scalar.TYPE_STRING));
:}

| T_DOLLAR_OPEN_CURLY_BRACES:start T_STRING_VARNAME:varName T_OPEN_RECT expr:index T_CLOSE_RECT:c T_CURLY_CLOSE:end
{:
	RESULT = new ReflectionVariableReference(startleft, endright, new ArrayVariableReference(varNameleft, cright, varName, index, ArrayVariableReference.VARIABLE_ARRAY));
:}
;

encaps_var_offset ::=
string_st:string
{:
	Scalar scalar = new Scalar(stringleft, stringright, string, Scalar.TYPE_STRING);
	RESULT = scalar;
:}

| T_NUM_STRING:num
{:
	Scalar scalar = new Scalar(numleft, numright, num, Scalar.TYPE_REAL);
	RESULT = scalar;
:}

| T_VARIABLE:varName
{:
	RESULT = new VariableReference(varNameleft, varNameright, varName, PHPVariableKind.LOCAL);
:}
;

internal_functions_in_yacc ::=
T_ISSET:start T_OPEN_PARENTHESE:openPar isset_variables:varList possible_comma T_CLOSE_PARENTHESE:end
{:
	varList.setStart(openParright);
	varList.setEnd(endleft);
	SimpleReference name = new SimpleReference(startleft, startright, "isset");
	PHPCallExpression result = new PHPCallExpression(startleft, endright, null, name, varList);
	RESULT = result;
:}

| T_EMPTY:start T_OPEN_PARENTHESE:openPar expr:expr T_CLOSE_PARENTHESE:end
{:
	SimpleReference name = new SimpleReference(startleft, startright, "empty");
	PHPCallArgumentsList exprList = new PHPCallArgumentsList(openParright, endleft);
	exprList.addNode(expr);
	PHPCallExpression result = new PHPCallExpression(startleft, endright, null, name, exprList);
	RESULT = result;
:}

| T_INCLUDE:include expr:expr
{:
	Include result = new Include(includeleft, exprright, expr, Include.IT_INCLUDE);
	RESULT = result;
:}

| T_INCLUDE_ONCE:include expr:expr
{:
	Include result = new Include(includeleft, exprright, expr, Include.IT_INCLUDE_ONCE);
	RESULT = result;
:}

| T_EVAL:start T_OPEN_PARENTHESE:openPar expr:expr T_CLOSE_PARENTHESE:end
{:
	SimpleReference name = new SimpleReference(startleft, startright, "eval");
	PHPCallArgumentsList exprList = new PHPCallArgumentsList(openParright, endleft);
	exprList.addNode(expr);
	PHPCallExpression result = new PHPCallExpression(startleft, endright, null, name, exprList);
	RESULT = result;
:}

| T_REQUIRE:include expr:expr
{:
	Include result = new Include(includeleft, exprright, expr, Include.IT_REQUIRE);
	RESULT = result;
:}

| T_REQUIRE_ONCE:include expr:expr
{:
	Include result = new Include(includeleft, exprright, expr, Include.IT_REQUIRE_ONCE);
	RESULT = result;
:}

| T_HALT_COMPILER:start T_OPEN_PARENTHESE:openPar function_call_parameter_list:parameters T_CLOSE_PARENTHESE:end
{:
	parameters.setStart(openParright);
	parameters.setEnd(endleft);
	SimpleReference name = new SimpleReference(startleft, startright, "__halt_compiler");
	PHPCallExpression result = new PHPCallExpression(startleft, endright, null, name, parameters);
	RESULT = result;
:}
;

isset_variables ::=
variable:var
{:
	PHPCallArgumentsList list = new PHPCallArgumentsList();
	list.addNode(var);
	RESULT = list;
:}

| isset_variables:varList T_COMMA variable:var
{:
	varList.addNode(var);
	RESULT = varList;
:}
;

string_st ::=
T_STRING:value
{: RESULT = value; :}

| T_DEFINE:value
{: RESULT = value; :}
;

yield_expr ::=
T_YIELD:token
{:
	RESULT = new YieldExpression(tokenleft, tokenright);
:}

| T_YIELD:token expr:expr
{:
	RESULT = new YieldExpression(tokenleft, exprright, expr);
:}

| T_YIELD:token expr:key T_DOUBLE_ARROW expr:expr
{:
	RESULT = new YieldExpression(tokenleft, exprright, key, expr);
:}

| T_YIELD_FROM:token expr:expr
{:
	RESULT = new YieldExpression(tokenleft, exprright, expr, YieldExpression.OP_FROM);
:}
;
