## -*- coding: utf-8;mode: org; fill-column: 80;  -*-
## This file is best viewed with GNU Emacs Org-mode: http://orgmode.org/

#+TITLE: Implementing Functions
- Spec :: https://github.com/php/php-langspec/blob/master/spec/13-functions.md#functions

* Scope
- [ ] function definition with arguments
- [ ] function invocation

** Optional for now
- [ ] generator functions
- [ ] nested functions
- [ ] variable functions
- [ ] anonymous functions
- [ ] argument passing by ref
- [ ] callable type
- [ ] __invoke

* Approach
- study simple language
- find a way to represent global scope (which executed first)
- find a way to represent variables in global scope
- translate results to function class and functions
  - is global scope a "main" function itself?

* Sample Code
#+begin_src php
  // with types
  function  increment(int $val): int {
      return $val + 1;
  }

  // without
  function increment($val) {
      return $val + 1;
  }

  increment(1337);
#+end_src

Anonymous functions

#+begin_src php
  $f = function($i) {
      return ($i % 2) == 0;
  };
#+end_src

** Type Annotations
- PHP 7 introduces strict types
- https://thevaluable.dev/php-7-type-hinting-pitfalls/
- weird type conversions apply if strict_typed=1 not set
- should we support type annotations?
  - it will make programming much less error prone
  - however, unless all code uses type annotations, we still need type conversions
  - so adding type annotation is extra work unless we make it required for all code

* How to represent functions in graal
- FrameSlot: represents a variable in a (stack) frame
- in order to implement functions, we need a way to access stack variables
- the truffle way suggest nodes to
  a. write local variable into current stack frame
  b. read parameters
  c. read local variables

- global and function scope should make representation in graal straight forward
- no scope walking, either function scope or not (with global keyword).

** Scoping
- https://phppot.com/php/variable-scope-in-php/
- PHP does not have lexical scope
- it has it's own concept of global and function scope
- A variable is either globally defined and not available within functions
- or locally defined within a function
- if global variable wants to be accessed within a function, global keyword must be used
- https://github.com/php/php-langspec/blob/master/spec/04-basic-concepts.md#scope

*** What about nested functions?
- same principle holds for nested function, no lexical scope defined

*** global, static
- global scope
- function scope (variables in functions, as well as function args)
- static scope (delcaring a var static within a function)
- super global (GLOBALS variable)

*** What happens to blocks within functions (if, or simply {})
- nothing, same rules apply, does not create a new scope

** Design ideas
*** Parser
- keep track of scope: function or global
- if function use a readNode to access virtual frame to get object
- if global use a readnode for globals
*** Function registry
- Hashmap: string -> function
*** PhpFunction node
- has a name
- has a call target


** SL implementation
- *SLFunction*
  - is TruffleObject
  - has name and rootcalltarget
  - Who does create it?
    - SLFunctionRegistry
- *SLFunctionRegistry*
  - maps name to slfunctions
- *SLRootNode*
  - is rootnode
  - root of all execution trees
  - either builtins
  - or user defined functions
  - a node that allows to be executed with #execute(VirtualFrame)
- *Expression Node vs StmtNode?*
  - stmt nodes not return something
  - expression is subclass of stmt
  - slroot hode has a body, which is a reference to a slstmt

- *SLRootNode vs EvalRootNode*
  - rootNode defines an execute(frame) method
  - slroot node and evalroot node contain a member which is a node
  - in execute(frame), they call bodyNode.executeGeneric(frame)
  - which then can be specialized by truffle during runtime
  - evalrootnode
    - has one child, a directCallNode, which is created from the main function and called with args from frame
    - used to run main function
  - slrootnode
    - is either function or builtin


*** TODO how does SLRootNode get its arguments?
- slrootnode is a rootnode and has an execute(frame) method.
- how are arguments to function given to slrootnode?

*** how are slfunction and slfunctionbody node releated with each other

*** create assignment (from function arguments)
- function arguments created as read argument node, which is an expression and passed as the value node to create assignment
#+begin_src java
    public SLExpressionNode createAssignment(SLExpressionNode nameNode, SLExpressionNode valueNode, Integer argumentIndex) {
        if (nameNode == null || valueNode == null) {
            return null;
        }

        String name = ((SLStringLiteralNode) nameNode).executeGeneric(null);
        FrameSlot frameSlot = frameDescriptor.findOrAddFrameSlot(
                        name,
                        argumentIndex,
                        FrameSlotKind.Illegal);
        lexicalScope.locals.put(name, frameSlot);
        final SLExpressionNode result = SLWriteLocalVariableNodeGen.create(valueNode, frameSlot);

        if (valueNode.hasSource()) {
            final int start = nameNode.getSourceCharIndex();
            final int length = valueNode.getSourceEndIndex() - start;
            result.setSourceSection(start, length);
        }
        result.addExpressionTag();

        return result;
    }
#+end_src

* Entry point for execution
- PHP has global scope and function scope
- how should we represent global scope?
- there is only one such scope
- we can represent it as a function which takes arguments no arguments but contains a special variable for argv, argc
- this can either be treated like any other function in graal php
- or as a special kind of function (with its own class)
 
** Do function def need to be above function calls in php source?
no
** Design idea: wrap everything within a main function
#+begin_src php
<?php
    
function main() {
$_argv = array("main.php", 1, "a");
$_argc = 3;


function test() {
    global $_argv;  // this is not effective, we cant access _argv at all
    global $_argc;
    echo "output: ";
    echo $_argc;
}

test();

}
main();
?>
#+end_src
Result: 
output


Issues:
- there is no way to access outer function variable
- with global, global scope is accessed which is not within a function
- php supports use keyword, to allow a function to access outer function variables
- https://stackoverflow.com/questions/2408908/is-it-possible-to-access-outer-local-variable-in-php
#+begin_src php
$bar = function() use(&$l) {
};
$bar();
#+end_src

#+begin_src php
<?php
    
function main() {
$_argv = array("main.php", 1, "a");
$_argc = 3;


$test = function() use (&$_argv, &$_argc) {
    echo "output: ";
    echo $_argc;
};

$test();

}


main();
?>
#+end_src
Output:
- output: 3

This would achieve the desired result

- We are free in changing the internals of our implementation as long as we correctly model global scope.
- However, making above code (which does not produce desired result)
  work, adds an exception in how source code has to be handled for
  main function
- does not scale well, for all possible globals we have to add these to the function definitions
- What about super globals?
*** Super globals
#+begin_src
    $GLOBALS
    $_SERVER
    $_GET
    $_POST
    $_FILES
    $_COOKIE
    $_SESSION
    $_REQUEST
    $_ENV
#+end_src


#+begin_src 
<?php
echo var_dump($GLOBALS);
echo var_dump($GLOBALS["argv"][1]);
?>

array(8) {
  ["_GET"]=>
  array(0) {
  }
  ["_POST"]=>
  array(0) {
  }
  ["_COOKIE"]=>
  array(0) {
  }
  ["_FILES"]=>
  array(0) {
  }
  ["argv"]=>
  array(2) {
    [0]=>
    string(9) "main3.php"
    [1]=>
    string(4) "1337"
  }
  ["argc"]=>
  int(2)
#+end_src

*** Pos. Design Solution
- do not wrap in a main function, treat main function differently than user defined functions
- GlobalEntryNode
  - is Expression
  - contains a stmt which throws exception on return
  - every function has a reference to variables defined in global scope, ie this node?
  - We would have userdef functions, builtins, and the global entry node


** Scoping in Truffle
